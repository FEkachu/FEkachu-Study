## 1. 호이스팅이 무엇인가요?

누군가가 나에게 호이스팅이 무엇이냐고 묻는다면 나는 아마 “자바스크립트에서 변수를 사용할 때, 변수의 선언과 초기화를 분리하고, 초기화는 두고 선언만 코드 맨 위로 옮기는 거요. 또 함수 선언문을 사용할 때에도 호이스팅이 일어납니다!”라고 답할 것이다.

```jsx
// 선언과 초기화를 분리함
const a;
a = 'hello';

// 선언과 초기화를 동시에
const b = 'hello';
```

위 코드에서는 변수를 `const` 키워드와 함께 선언하였다. 보통 우리가 코드를 작성할 때 a와 같은 예시처럼 선언과 초기화를 따로 하는 일은 자주 없지만 여튼 예시를 위하여 위와 같이 작성하였다. a 예시에서, a를 선언한 코드 다음 줄에서 만약 a를 사용하는 코드를 적는다면? a is not defined 라는 오류를 확인할 수 있을 것이다. 그 이유는 초기화 전에 변수 a를 사용하려했기 때문이다. 하지만 만약 const 키워드가 아닌 var 키워드로 변수를 선언했다면? 그리고 초기화 전에 var 키워드로 선언된 a를 사용하려 했다면 또 오류가 발생할까? 이번에는 오류가 발생하지 않는다. 대신에 a는 undefined 값을 가지고 있다. 이처럼 var 키워드는 선언과 동시에 변수를 undefined로 초기화한다.

[호이스팅 - 용어 사전 | MDN](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)

## 2. 그럼 호이스팅은 왜 일어나나요?

위처럼 헷갈리는 경우가 있는데도 왜 호이스팅은 존재할까? 호이스팅은 사실 특별한 기능이 아니며 단지 자바스크립트의 컴파일 과정에서 일어나는 전처리 과정이다. 자바스크립트를 단순히 인터프리터 언어라고 생각하기 쉬운데 자바스크립트 또한 컴파일 과정을 거친다. 다만 자바스크립트 엔진 내부에서 실행중 컴파일이 필요한 경우메나 내부에서 컴파일을 진행한다.

엔진이 JS 파일을 받아 파싱하며 AST를 구축하는 과정 다음에 인터프리터가 코드를 읽으며 실행한다. 그 코드를 실행하는 과정에서 프로파일러가 그 과정을 지켜보며 최적화할 수 있는 코드(주로 반복되는 코드)를 컴파일러에게 전달해준다. 그리고 전달받은 코드를 컴파일러가 최적화하고 최적화된 코드를 원래 있던 코드와 바꿔준다. 코드를 우선 인터프리터 방식으로 실행하고 필요할 때 컴파일 하는 이 방식을 JIT(Just-In-Time) 컴파일러라고 부른다.

이때 호이스팅은 코드가 실행되기 전(컴파일 시점)에 선언을 실행 컨텍스트에 저장하는 과정이다.
![Untitled](https://user-images.githubusercontent.com/62709718/182160023-6089ba4b-2300-4430-9d7d-3ec5b0ad8bad.png)

## 3. 그렇다면 const와 let은 호이스팅의 대상이 아닌가요?

결론부터 말하자면 `const`와 `let`도 호이스팅의 대상이다. 위에서 `const`와 `let` 키워드를 사용한 변수는 선언과 초기화가 동시에 일어나지 않기 때문에 선언 후 초기화를 하지않는다면 그 값을 사용할 수 없다고 하였는데(var도 선언과 초기화가 사실 정말 동시에 일어나는 것은 아니다. 하지만 선언 직후에 일어난다.) 이는 `TDZ`(Temporal Dead Zone)의 제한 때문에 초기화 전까지 해당 변수에 접근할 수 없기 때문이다.

자바스크립트는 오직 **선언**만을 호이스팅한다.

## 4. 선언부가 코드의 상단부로 끌어올려진다고 하였는데, 물리적으로 정말 상단으로 끌어올려지는 건가요?

이는 비유적인 표현이다. 정확히 표현하자면 자바스크립트 엔진이 코드를 컴파일할 때, 선언된 식별자들을 실행 컨텍스트에 저장한다. 그 후 실행 단계에서 초기화가 이루어진다. 이 행위를 끌어올린다라고 표현하는 것이며 코드 안에서 선언을 최상단에 작성한 것과 동일하게 동작한다.

만약 선언이 함수 밖에서 선언되었다면 전역 스코프에, 함수 내에서 선언됐다면 해당 함수 스코프에 저장된다.

[[JavaScript] 호이스팅(Hoisting)이란?](https://jee-goo.tistory.com/54)

## 5. TDZ는 무엇인가요?

```jsx
white; // throws `ReferenceError`
const white = '#FFFFFF';

white
```

두번째줄 전까지 white 변수는 TDZ에 있다. TDZ에 있는 white 변수에 접근하게 되면 ReferenceError: Cannot access 'white' before initialization 자바스크립트 에러가 발생한다.
![Untitled](https://user-images.githubusercontent.com/62709718/182160085-99d30f0a-2207-4aaf-852d-7ff7c05a68ee.png)


const와 let 키워드로 선언한 변수는 초기화 전 줄까지 TDZ에 있어서 사용이 불가능하다. 이 TDZ는 const와 let에만 존재하는 것이 아니다. class 구문, constructor() 내부의 super() 구문에도 TDZ가 존재하고 기본 함수 매개변수에도 존재한다. 여기서는 기본 함수 매개변수의 TDZ 경우만 살펴보고 다른 두가지 경우는 아래 블로그에서 찾아보도록 하자.

기본 매개변수는 글로벌과 함수 스코프 사이의 중간 스코프에 위치한다. 이때 기본 매개변수는 TDZ 제한이 있다.

```jsx
const a = 2;
function square(a = a) {
  return a * a;
}
// Does not work!
square(); // throws `ReferenceError`
```

기본 매개변수 a는 선언 전에 `a = a` 표현식의 오른쪽에서 사용되었다. 이때 a에서 참조 에러가 발생한다. 기본 매개변수는 선언 및 초기화 다음에 사용되어야 한다. 이 경우 init과 같은 다른 변수로 선언하여 사용한다.

```jsx
const init = 2;
function square(a = init) {
  return a * a;
}
// Works!
square(); // => 4
```

위에서 설명한 것들과 반대로 var, function 선언은 TDZ의 영향을 받지 않고 현재 스코프에서 호이스팅된다. 또한 흥미롭게도 import 모듈 또한 역시 호이스팅 된다.

정리하자면 TDZ는 선언 전에 변수를 사용하는 것을 허용하지 않는 ‘임시적인 죽은 공간'이며, 코드 컨벤션에 좋다. 이와 반대로 var 키워드로 선언한 변수는 선언 전에도 사용할 수 있기 때문에 이를 피하는 것이 좋다.

[TDZ을 모른 채 자바스크립트 변수를 사용하지 말라](https://ui.toast.com/weekly-pick/ko_20191014)
