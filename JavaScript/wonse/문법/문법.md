## 1. 문과 표현식
### 1.1 문의 완료 값
자바스크립트에서 문(statement)는 문장(sentence), 표현식(expression)은 어구(phrase), 연산자는 구두점/접속사에 해당된다. 자바스크립트에서 모든 표현식은 단일한, 특정한 결과값으로 계산된다.

모든 문은 완료 값(completion value)을 가진다. 브라우저 개발자 콘솔 창에서 문을 타이핑해봤을 때 `undefined`를 자주 볼 수 있는데 완료 값이 `undefined`이기 때문이다. 하지만 이것에 대해 고민해본 적은 없었는데 콘솔 창이 내어준 이 완료 값은 개발자가 내부 프로그램에서 사용할 수 있는 값은 아니다. 완료 값을 포착하기 위해 ES7 명세에는 `do 표현식`이 제안되었다. 
```javascript
let a, b;
a = do {
    if (true) {
        b = 4 + 38;
    }
}
```

`do 표현식`은 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.

### 1.2 표현식의 부수 효과
대부분의 표현식에는 부수 효과가 없다.
```javascript
let a = 2;
let b = a + 3;
```
표현식 a + 3 자체는 가령 a 값을 바꾸는 등의 부수 효과가 전혀 없다. 단지 b = a + 3 문에서 결괏값 5가 b에 할당될 뿐이다.

그렇다면 부수 효과를 지닌 표현식의 예를 몇가지 정리해보겠다.
```javascript
let a = 42;
let b = a++;
a; // 43
b; // 42
```
위 코드에서 표현식 a++이 하는 일은 두 가지다. a의 현재 값 42를 반환(그리고 b에 할당까지)하고 a값을 1만큼 증가시킨다.
```javascript
const obj = {
    a: 42
};
obj.a; // 42
delete obj.a; // true
obj.a; // undefined
```
`delete` 연산자의 결괏값은 유효한/허용된 연산일 경우 true, 그 외에는 false다. 이 연산자의 부수 효과는 바로 프로퍼티(혹은 배열 슬롯)를 제거하는 것이다.

```javascript
let a;

a = 42; // 42
a; // 42
```
`a = 42`에서 =연산자는 부수 효과와는 무관해 보이지만 `a = 42` 문의 실행 결과는 이제 막 할당된 값(42)이므로 42를 a에 할당하는 자체가 본질적으로 부수 효과다.
```javascript
let a, b, c;
a = b = c = 42;
```
`c = 42` 평가 결과는 42가 되고, `b = 42` 평가 결과는 42가 된다. 결국 `a = 42`로 평가된다.

## 2. 연산자 우선순위
```javascript
let a = 42, b;
b = a++, a;

a; // 43
b; // 42
```
위의 결과는 ++연산자가 =연산자보다 우선수위가 낮기 때문에 발생한다. `b = a++, a`를 엔진은 (`b = a++`), a로 해석한다. `a++`는 ++연산자가 a값을 변경하는 부수 효과를 일으키기 전 b에 42값을 할당한다. 따라서 위의 예시 코드는 연산자 우선 순위를 알아야하는 이유를 보여준다.

### 2.1 단락 평가
&&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛴다. 예를 들어 `a && b`에서 a가 falsy면 b는 쳐다보지도 않는다. && 연산 결과가 이미 false로 굳어진 마당에 애써 b를 조사할 필요가 없다. 마찬가지로 `a || b`에서 a가 truthy면, 이미 전체 결괏값은 true로 확정되므로 b는 관심을 둘 이유가 없다.

### 2.2 결합성
연산자 우선순위가 다른 연산자들은 그 순위에 따라 처리된다. 하지만 우선순위가 동일한 다수의 연산자라면 그 처리 순서가 어떻게 될까? 이 질문을 생각했을 때 나는 '무조건 좌측부터 아냐?' 라고 생각했다.

일단 처리 방향이 좌측 -> 우측인지, 우측 -> 좌측인지 하는 문제는 왜 중요할까? 다음 함수 호출과 같이 표현식이 부수 효과를 일으킬 수 있기 때문이다.
```javascript
let a = foo() && bar();
```
`foo()`함수를 먼저 호출한 뒤, 그 결괏값에 따라 `bar()`호출 여부를 결정한다. 만일 `bar()`가 `foo()`앞에 있다면 전혀 다른 식으로 프로그램이 흘러갈 것이다. 하지만 위 예시는 자바스크립트의 기본 처리 순서에 따라 단순히 좌측 -> 우측 순서로 처리된 것이지 결합성과는 무관하다.

`a && b && c`같은 표현식에서는 암시적인 그룹핑이 발생한다. 즉 `a && b`와 `b && c`중 어느 한 편이 먼저 평가된다. &&는 좌측부터 결합하므로 (||도 마찬가지) `a && b && c`는 `(a && b) && c`와 같다. 설사 우측부터 결합하더라도 결과가 같다. 동일한 값에 대하여 동일한 표현식은 항상 동일한 순서로 평가된다.

하지만 모든 연산자가 다 그런 것은 아니다. 결합 방향이 좌/우측 어느 쪽인지에 따라 완전히 다르게 작동하는 연산자도 있다. 삼항 연산자가 그 예시다.
```javascript
a ? b : c ? d: e;
```
삼항 연산자는 우측 결합성 연산자인데 그럼 어떤 순서로 처리될 것인가? `a ? b : (c ? d :e)`순서로 처리된다. &&, ||와는 달리, 우측부터 결합하므로 결과가 달라진다.

=도 우측 결합성(그룹핑) 연산자 중 하나다.
```javascript
let a, b, c;
a = b = c = 42;
```

## 3. 세미콜론 자동 삽입
`ASI(Automatic Semicolon Insertion`는 자바스크립트 프로그램의 세미콜론이 누락된 곳에 엔진이 자동으로 세미콜론을 삽입하는 것을 말한다. 사실 단 하나의 세미콜론이라도 누락되면 자바스크립트 프로그램은 돌아가지 않는데 평소엔 이를 인지하지 못했다. 그 이유는 자바스크립트 코딩 시 세미콜론을 쓰지 않아도 `ASI` 덕분에 오류 없이 코드가 실행됐기 때문이다. 단 `ASI`는 새 줄에만 적용된다.

명세에는 분명히 `ASI`가 에러 정정 루틴이라고 씌어 있다. 여기서 에러란 구체적으로는 파서 에러다. 다른 말로 풀이하면 `ASI`가 파서를 너그럽게하여 에러를 줄이는 것이다.

파서 에러는 프로그램을 부정확하게/잘못 코딩했기 때문에 나는 것일 뿐, 그 외의 경우는 없다. 따라서 `ASI`가 꼼꼼히 파서 에러를 정정했음에도 발생한 파서 에러는 프로그램 작성자가 정말 잘못 짠 코드가 있다는 증거다.

## 4. 에러
자바스크립트는 하위 에러타입(TypeError, ReferenceError, SyntaxError 등)뿐만 아니라, 일부 에러는 컴파일 시점에 발생하도록 문법적으로 정의되어 있다.

특히 자바스크립트에는 오래 전부터 컴파일 도중 조기 에러로 붙잡아 던지게 되어 있는 여러가지 특정 조건들이 있었다. 이러한 에러는 코드가 실행도 되기 전에 발생하므로 `try...catch`로 잡을 수 없으며, 프로그램 파싱/컴파일이 실패한다.

```javascript
let a = /+foo/; // 에러!

let b;
42 = a; // 에러!

function bar(a, b, a) { "use strict"; } // 에러!
```
### 4.1 너무 이른 변수 사용
`TDZ`는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.
```javascript
{
    typeof a; // undefined
		typeof b; // ReferenceError! (TDZ)
		let b;
}
```
재밌는 사실은 원래 typeof 연산자는 선언되지 않느 변수 앞에 붙여도 오류는 나지 않는데 `TDZ` 참조 시에는 이러한 안전장치가 없다는 사실이다.

## 5. 함수 인자
TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다.
```javascript
let b = 3;
function foo(a = 42, b = a + b + 5) {
    // ...
}
```
두 번째 할당문에서 좌변 b는 아직 TDZ에 남아 있는 b를 참조하려고 하기 때문에 에러를 던진다. 그러나 이 시점에서 인자 a는 TDZ를 밟고 간 이후여서 문제가 없다.

## 6. try...finally
catch, finally 둘 다 같이 써도 상관은 없지만 원래 try 이후에는 catch, finally 중 catch, finally 중 하나만 핈수이다.

finally 절의 코드는 반드시 실행되고 다른 코드로 넘어가기 전에 try 이후부터(catch가 있으면 catch 다음부터) 항상 실행된다. 어떤 의미에서 finally 절은 다른 블록 코드에 상관없이 필히 실행되어야 할 콜백 함수와 같다고 보면 된다.
```javascript
function foo() {
    try {
        return 42;
    }
    finally {
        console.log("hello");
    }
    
    console.log('blabla');
}

console.log(foo());
// hello
// 42
```
return 42에서 foo() 함수의 완료 값은 42로 세팅되고, try 절의 실행이 종료되면서 곧바로 finally 절로 넘어간다. 그 후 foo() 함수 전체의 실행이 끝나고 완료 값은 호출부 console.log() 문에 반환된다.

만약 finally 절에서 예외가 던져지면, 이전의 실행 결과는 모두 무시한다. 즉, 이전에 try 블록에서 생성한 완료 값이 있어도 완전히 사장된다. 또한 finally 절의 return은 그 이전에 실행된 try나 catch 절의 return을 덮어쓰는 특출한 능력을 갖고 있는데, 단 반드시 명시적으로 return 문을 써야한다.
```javascript
function foo() {
    try {
        return 42;
    }
    finally {
    }
}
function bar() {
    try {
        return 42;
    }
    finally {
        return;
    }
}
function baz() {
    try {
        return 42;
    }
    finally {
        return "Hello";
    }
}

foo(); // 42
bar(); // undefined
baz(); // Hello
```
보통 함수에서는 `return`을 생략해도 `return;` 또는 `return undefined;` 한 것으로 치지만, finally 안에서 `return`을 빼면 이전의 `return`을 무시하지 않고 존중한다.


