## 1. 렉스 타임

```jsx
function foo(a) {
	var b = a * 2;

	function bar(c) {
		console.log(a, b, c);
	}
	
	bar(b * 3);
}

foo(2); // 2, 4, 12
```

위와 같은 코드가 있을 때 자바스크립트 엔진은 어떠한 순서로 변수를 검색할까? 만약 a를 찾으려고 한다면 가장 안쪽 스코프 버블인 bar() 함수의 스코프부터 검색을 시작할 것이다. 여기서 a를 찾지 못하면 다음으로 가장 가까운 스코프 버블인 foo() 함수의 스코프에서 검색을 할 것이다. b와 c의 경우도 마찬가지이다.

**스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단한다.** 평소 코딩을 할때 스코프가 다르다는 이유로 여러 중첩 스코프 층에 걸쳐 같은 확인자 이름을 정의한 적이 있는데, 이를 shadowing이라 한다. 섀도잉과 상관없이 스코프 검색은 항상 실행 시점에서 가장 안쪽 스코프에서 시작하여 최종 목표와 일치하는 대상을 찾으면 멈추기 때문에 이런 shadowing을 하여도 문제가 없었던 것이다.

이러한 구조의 스코프는 **렉싱 타임에 정의되고 그 이름은 렉시컬 스코프**이다. 어떤 함수가 어디서 어떻게 호출되냐기보다는 함수가 선언된 위치에 따라 스코프가 결정된다.

## 2. 렉시컬 속이기

엔진은 함수가 선언된 위치에 따라 렉시컬 스코프를 결정한다. 이는 컴파일 과정 중 렉스 타임에 이루어지고 자바스크립트 엔진은 컴파일레이션 단계에서 상당수의 최적화를 진행한다. 만약 엔진이 결정한 이 렉시컬 스코프를 조작한다면 컴파일 단계에서 이뤄졌던 최적화는 어떻게 될까? 상식적으로 생각해도 당연히 안 좋아질 것이고 굳이 이렇게 최적화를 망가뜨리면서까지 렉시컬 스코프를 조작할 이유가 없다.

렉시컬 스코프를 속일 수 있는 방법은 두가지가 있는데 바로 `eval`과 `with`이다.

### eval

eval() 함수는 처음 작성한 코드에 프로그램에서 생성한 코드를 집어넣어 마치 처음 작성될 때부터 있던 것처럼 실행한다.

```jsx
function foo(str, a) {
	eval(str); // cheating!
	console.log(a, b);
}

var b = 2;
foo("var b = 3;", 1); // 1, 3
```

위 코드에서 문자열 "var b = 3;"은 eval()이 호출되는 시점에 원래 있던 코드인 것처럼 처리된다. 원래대로라면 foo() 함수의 콘솔문의 b는 바깥 영역의 b를 찾아야한다. 하지만 eval() 함수에 의해 렉시컬 스코프가 수정되면서 안쪽의 b를 찾아 결괏값이 저렇게 나오는 것이다. 기본적으로 코드 문자열이 하나 이상의 변수 또는 함수 선언문을 포함하면 eval()이 그 코드를 실행하면서 eval()이 호출된 위치에 있는 렉시컬 스코프를 수정한다.

어쨌든 성능 저하를 감수할 만큼 동적으로 생성한 코드를 프로그램에서 사용하는 경우는 거의 없기 때문에 사용하지 않는 것이 좋다.

### with

with는 일반적으로 한 객체의 여러 속성을 참조할 때 객체 참조를 매번 반복하지 않기 위해 사용하는 일종의 속기법이다. 속기법이라 하면 코드를 빨리 작성, 간결하게 작성하는 방법을 말하는 것으로 보인다.

하지만 with는 속기법 이상의 효과가 있다.

```jsx
function foo(obj) {
	with (obj) {
		a = 2;
	}
}

var o1 = {
	a: 3
};

var 02 = {
	b: 3
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2
```

위 코드에서 주목해볼 줄은 마지막 줄이다. with에서 작성했던 a = 2가 전역 변수로 작동한다. with 문은 속성을 가진 객체를 받아 마치 하나의 독립된 렉시컬 스코프처럼 취급한다. 또한 with 블록 안에서 일반적인 var 선언문이 수행될 경우 선언된 변수는 with 블록이 아니라 with를 포함하는 함수의 스코프에 속한다.

with 문은 넘겨진 객체를 가지고 난데없이 사실상 하나의 새로운 렉시컬 스코프를 생성한다. 이때 o2의 스코프, foo()의 스코프, 글로벌 스코프에서 a 확인자를 찾을 수 없으므로 “a = 2” 가 수행되면 자동으로 그에 해당하는 글로벌 변수가 생성되는 것이다.

## 3. 자바스크립트 엔진의 최적화

위에서 자바스크립트 엔진은 컴파일레이션 단계에서 상당수의 최적화를 진행한다고 하였는데, 그 최적화 기법에는 무엇이 있는지 알아보고자 한다.

### a. 히든 클래스

자바스크립트는 동적 타입 언어이며 객체에서 속성을 즉시 추가하거나 제거할 수 있다. 하지만 이 접근 방식은 자바스크립트의 성능을 떨어뜨리는 동적 조회를 더 필요로 하게 된다.

V8 엔진은 히든 클래스를 사용해 이 문제를 해결하고 자바스크립트 실행을 최적화한다. 빈 객체를 생성하면 V8은 오프셋 없이 해당 히든 클래스를 만든다. 그런 다음 새 프로퍼티를 추가해 해당 객체를 수정한다. 이제 V8 엔진은 이전 히든 클래스의 모든 프로퍼티를 상속해 새 히든 클래스를 생성하고 이름 프로퍼티를 오프셋 0에 할당한다. 이렇게 하면 컴파일러는 프로퍼티 이름에 접근할 때 사전형 탐색을 우회할 수 있다.

V8이 기존의 히든 클래스를 재사용할 때, 성능이 훨씬 향상된다. 따라서, 자바스크립트 코드의 성능 향상을 최대화하려면 동적 프로퍼티 추가를 줄여야 한다.

### b. 인라이닝

미리 가능한 많은 코드를 인라이닝한다. 인라이닝이란 호출 지점(함수가 호출된 곳의 코드 위치)을 호출된 함수의 내용으로 바꾸는 과정이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/73d8a46f-4109-4e21-8fbd-8c9fe90a5d31/Untitled.png)

### c. 인라인 캐싱

V8은 최근 메소드 호출에 파라미터로 전달된 객체 타입의 캐시를 유지하고 이 정보를 이용해 앞으로 파라미터로 넘어올 객체의 타입에 대한 가정을 한다. 만약 그 가정이 잘 된다면 객체의 속성에 접근할 방법을 알아내는 과정을 수행하지 않아도 되며 그 대신 객체의 히든 클래스에 대해 이전에 찾아서 저장했던 정보를 사용할 수 있다.

### d. 가비지 컬렉션

가비지컬렉션 비용을 통제하고 그 수행을 좀 더 안정적으로 하기위해 V8은 점진적 마킹을 이용한다. 힙 전체를 훑어서 가능한 모든 객체를 마킹하는 대신 힙의 일부만을 확인한 다음 정상적인 자바스크립트 실행을 계속한다. 이를 통해 일상적인 실행에는 매우 짧은 코드 중단만 일어난다.

[자바스크립트 성능의 비밀 (V8과 히든 클래스)](https://ui.toast.com/weekly-pick/ko_20210909)

[자바스크립트는 어떻게 작동하는가: V8 엔진의 내부 + 최적화된 코드를 작성을 위한 다섯 가지 팁](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9)
