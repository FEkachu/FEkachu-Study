# ➰ 스코프 ➰

## 1. 스코프란?

    스코프(Scope, 유효범위) : 식별자를 찾아내기 위한 규칙. JS는 이 규칙대로 식별자를 찾는다.

- 예제

  ```JS
  var x = 'global'

  function foo () {
      var x = 'function scope';
      console.log(x);
  }

  foo();
  console.log(x);
  ```

  위 코드에서 전역에 선언된 변수 x는 어디에서는 참조할 수 있다. 하지만 함수 foo 내에서 선언된 변수 x는 함수 foo 내부에서만 참조 가능하다. 이러한 규칙을 **스코프**라고 한다.

- 스코프가 없다면 ?  
   같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없을 것이다.

## 2. 자바스크립트의 스코프

대부분의 C-family language는 **블록 레벨 스코프**를 따른다.

- 블록 레벨 스코프  
  코드 블록({...})내에서 유효한 스코프를 의미한다.

하지만 자바스크립트는 **함수 레벨 스코프**를 따른다!

- 함수 레벨 스코프  
  함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 참조 불가

```js
var x = 0;
{
  var x = 1;
  console.log(x); //1
}
console.log(x); //1
```

단, ECMAScript6에서 도입된 let 키워드 사용하면 블록 레벨 스코프 사용 가능

```js
let y = 0;
{
  let y = 1;
  console.log(y); //1
}
console.log(y); //0
```

## 3. 전역 스코프(Global scope)

var 키워드로 선언한 전역 변수는 전역 객체 `window` 의 프로퍼티이다.

자바스크립트는 타 언어와 달리 특별한 시작점이 없어서 전역 변수나 함수를 선언하기 쉬우며 전역 변수를 남발하게 하는 문제를 야기시킨다.

전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당의 문제가 생길 수 있으므로 사용을 억제해야 한다.

## 4. 비 블록 레벨 스코프

```js
if (true) {
  var x = 5; //x는 전역변수
}
console.log(x);
```

자바스크립트는 블록 레벨 스코프를 사용하지 않으므로 **함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다해도 모두 전역 스코프**를 갖게 된다.

## 5. 함수 레벨 스코프

- 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다.

  ```js
  var a = 10; //전역

  (function () {
    var b = 20; //지역
  })();

  console.log(a); //10
  console.log(b); //not defined
  ```

- 변수명이 중복된 경우, 지역변수를 우선하여 참조한다.

  ```js
  var x = "global";

  function foo() {
    var x = "local";
    console.log(x);
  }

  foo(); // local
  console.log(x); //global
  ```

- 함수 내에 존재하는 내부 함수

  ```js
  var x = "global";

  function foo() {
    var x = "local";
    console.log(x); //local

    function bar() {
      console.log(x);
    }

    bar(); // local
  }
  foo();
  console.log(x); //global
  ```

  함수 bar에서 참조하는 변수 x는 함수 foo에서 선언된 지역변수이다.

- 함수 영역에서 전역변수 참조 가능하므로 값 변경 가능, 내부 함수의 경우 전역변수는 물론 상위 함수에서 선언한 변수 접근/변경 가능

  ```js
  var x = 10;

  function foo() {
    x = 100;
    console.log(x);
  }
  foo(); //100
  console.log(x); //100
  ```

- 중첩 스코프는 가장 인접한 지역 우선 참조

  ```js
  var x = 10;

  function foo() {
    var x = 100;
    console.log(x); //100

    function bar() {
      x = 1000;
      console.log(x);
    }

    bar(); //1000
  }
  foo();
  console.log(x); //10
  ```

  ```js
  var foo = function () {
    var a = 3,
      b = 5;

    var bar = function () {
      var b = 7,
        c = 11;

      // a는 3, b는 7, c는 11

      a += b + c;

      // a는 21, b는 7, c는 11
    };

    // a는 3, b는 5, c는 not defined

    bar();

    // a는 21, b는 5, c는 not defined
  };
  ```

## 6. 렉시컬 스코프

자바스크립트를 비롯한 대부분의 언어는 **렉시컬 스코프**를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다.

- 렉시컬 스코프  
  함수를 **어디에 선언하였는지**에 따라 상위 스코프를 결정한다.

- 동적 스코프  
  함수를 **어디서 호출하였는지**에 따라 상위 스코프를 결정한다.

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); //1
bar(); //1
```

## 7. 암묵적 전역

선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.

```js
var x = 10;

function foo() {
  y = 20;
  console.log(x + y);
}

foo(); //30
```

위 코드에서 `y = 20` 이 실행되면 참조 에러가 발생할 것처럼 보이지만, y는 마치 선언된 변수처럼 동작한다.

foo 함수가 호출되면 자바스크립트 엔진은 스코프 체인을 통해 y가 선언된 변수인지 확인한다. 이때 변수 y의 선언을 찾지 못하면 `y = 20` 을 `window.y = 20` 으로 해석하여 프로퍼티를 동적 생성한다. 결국 y는 마치 전역 변수처럼 동작하는데, 이러한 현상을 **암묵적 전역**이라 한다.

y는 변수 선언 없이 단지 전역 객체의 프로퍼티로 추가된 것이기 때문에, 변수가 아닌 y는 변수 호이스팅이 발생하지 않으며 delete 연산자로 삭제가 가능하다.
