# 📍 스코프

## 1. 컴파일러 이론

자바스크립트는 인터프리터 언어로 분류되지만, 사실은 컴파일러 언어이다. 코드를 수행하기 전에 컴파일러가 언어를 처리하는 과정을 compilation이라고 하며, compilation은 보통 3단계를 거친다.

1. 토크나이징/렉싱 (Tokenizing/Lexing)

   문자열을 나누어 의미있는 조각, 즉 토큰으로 만드는 과정.

   ```jsx
   var a = 2;
   ```

   위 코드에서 토큰은 다음과 같다.

   - var
   - a
   - =
   - 2
   - ;

   토크나이저와 렉서의 역할을 합하여 Lexical analyze라고 한다.

   토크나이징은 코드를 토큰화하는 과정이고, 렉싱은 토크나이징 과정에서 생성된 토큰들을 분석하여 의미를 부여하는 과정이다.

2. 파싱 (Parsing)

   Tokenizing 또는 Lexing 과정에서 만들어진 토큰 배열을 프로그램의 문법 구조를 반영하여 트리 형태로 바꾸는 과정. 파싱의 결과로 만들어진 트리는 AST(추상 구문 트리)이다.

   - AST(Abstract Syntax Tree)
     특정 프로그래밍 언어로 작성된 프로그램 소스코드를 각각 의미별로 분리하여 컴퓨터가 이해할 수 있는 구조로 변경시킨 트리.

   `var a = 2;` 의 트리는 먼저 변수 선언이라 부르는 최상위 노드에서 시작하고, 최상위 노드는 a의 값을 가지는 확인자와 대입 수식이라 부르는 자식 노드를 가진다. 대입 수식 노드는 2라는 값을 가지는 숫자 리터럴을 자식 노드로 가진다.

3. 코드 생성 (Code generation)

   Parsing 과정에서 만들어진 AST를 컴퓨터가 실행할 수 있는 기계어로 바꾸는 과정.

자바스크립트 엔진은 이 세 가지 단계뿐 아니라 많은 부분에서 다른 언어의 컴파일러보다 보다 훨씬 복잡하다. 예컨대, 자바스크립트 엔진은 파싱과 코드 생성 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시 성능을 최적화 한다.

자바스크립트 엔진이 기존 컴파일러와 다른 점은 컴파일레이션을 보통 코드가 실행되기 바로 직전에 수행하기 때문에 최적화할 시간이 많지 않다는 것이다.

### ※ 컴파일러 vs 인터프리터

컴퓨터는 고급 언어로 작성된 코드를 이해하지 못하기 때문에 이를 기계어로 번역해주는 과정이 필요한데, 번역을 하는 방식에는 두 가지가 있다.

- 컴파일러
  - 전체 파일을 스캔하여 한번에 기계어로 번역한다.
  - 초기 스캔 시간이 오래 걸리지만, 한번 실행 파일이 만들어지면 다음 실행 때 이전에 만들었던 실행 파일을 실행하기 때문에 실행 속도가 빠르다.
  - 기계어 번역 과정에서 더 많은 메모리를 사용한다. 오브젝트 코드 파일을 만들고 이를 묶어서 하나의 실행 파일로 만드는 링킹 작업을 하기 때문이다.
  - 전체 코드를 스캔하는 과정에서 모든 오류를 한번에 출력해주기 때문에 실행 전에 오류를 알 수 있다.
  - 전체 코드를 컴파일 후에 오류를 알려주므로 수정이 용이하지 않다. 수정 사항이 발생하면 다시 컴파일을 해야 한다.
  - 대표적으로 C, C++, JAVA
- 인터프리터
  - 프로그램 실행 시 한 번에 한 줄씩 번역한다.
  - 한 번에 한 줄씩 번역 후 실행시키기 때문에 실행 속도가 느리다.
  - 오브젝트 코드 생성 과정이 없기 때문에 메모리 효율이 좋다.
  - 프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지시키기 때문에 실행 후에 오류를 알 수 있다.
  - 소스 코드를 한 줄씩 실행하므로 실시간 코드 수정이 가능하다.
  - 대표적으로 Python, Ruby, Javascript

## 2. 스코프란?

스코프란 변수를 찾아내기 위한 규칙이다.

```jsx
var a = 2;
```

- 컴파일 과정

  1. 컴파일러가 `var a` 를 만나면 변수 a가 스코프 안에 있는지 확인한다. 있으면 선언을 무시하고 넘어가고, 없으면 새로운 변수 a를 스코프 내에 선언하기를 요청한다.
  2. 다음으로 컴파일러는 대입문 `a = 2` 를 처리하기 위해 엔진이 실행할 수 있는 코드를 생성한다. 코드가 생성이 되면 엔진이 동작한다. 엔진은 현재 스코프에서 a 변수를 접근할 수 있는지 확인하고, 가능하면 변수 a를 사용하고, 없으면 상위 스코프를 확인한다.

  → **컴파일러**가 변수를 선언하고, **엔진**이 스코프에서 변수를 찾고 대입하는 역할을 한다.

## 3. 컴파일러

위의 2단계에서 컴파일러가 생성한 코드를 실행할 때 엔진은 변수가 선언된 적이 있는지 스코프에서 검색한다. 이때 엔진이 어떤 종류의 검색을 하느냐에 따라 검색 결과가 달라지는데, 검색 방법에는 **LHS 검색**과 **RHS 검색** 두 가지가 있다.

- LHS(Left-Hand Side) 검색
  대입되는 변수를 찾기 위해 사용되며, 변수의 값이 담긴 공간(컨테이너)을 찾는다. 위의 코드에서 변수 a를 찾기 위해 LHS 검색이 사용된다.
- RHS(Right-Hand Side) 검색
  특정 변수의 값을 찾는 검색에서 사용된다.
  ```jsx
  // RHS 검색이 사용되는 예시
  console.log(a);
  add(num1, num2);
  str = anotherstr; // str은 LHS, anotherstr은 RHS
  ```

LHS와 RHS는 변수가 아직 선언되지 않았을 때 서로 다르게 동작한다.

**LHS의 경우** 최상위 스코프까지 검색을 마치고도 변수를 찾지 못하면 해당 이름의 **글로벌 변수를 새로 만든다.** 선언하지 않은 변수에 값을 대입할 수 있는 이유도 이러한 엔진의 동작 때문이다.

**RHS의 경우** 검색을 마치고도 변수를 찾을 수 없다면 **Reference Error**를 출력하게 된다.

하지만 **엄격 모드(Strict Mode)** 에서는 글로벌 변수를 암시적으로 생성할 수 없기 때문에 LHS 검색에 실패했을 때도 **Reference Error**를 출력하게 된다.

RHS 검색 결과 변수를 찾았지만 그 값을 가지고 불가능한 일을 하려고 할 경우(함수가 아닌 값을 함수처럼 실행하거나 null이나 undefined 값을 참조할 때)에는 TypeError를 발생시킨다.

ReferenceError는 스코프에서 대상을 찾았는지와 관계가 있고, TypeError는 결과값을 가지고 적합하지 않거나 불가능한 시도를 한 경우와 관계가 있다.

- 예제

  ```jsx
  function foo(a) {
    var b = a;
    return a + b;
  }

  var c = foo(2);
  ```

  1. 모든 LHS 검색
     - foo 함수의 parameter a에 값 2를 대입하기 위해 a 검색
     - `var b = a;` 대입을 위해 b 검색
     - `var c = foo(2);` 를 위해 c 검색
  2. 모든 RHS 검색
     - `c = foo(2);` 에서 foo()의 값
     - `b = a;` 에서 a의 값 검색
     - `a + b` 를 위해 a 값 검색
     - `a + b` 를 위해 b 값 검색

## 4. 중첩 스코프

엔진이 변수에 값을 대입할 때 현재 스코프에서 변수를 검색하고, 찾지 못하면 중첩 스코프를 찾는다. 우리가 상위에서 선언된 변수나 함수를 사용할 수 있는 것처럼, 엔진은 중첩 스코프 검색을 통해 현재 스코프에 선언되어 있지 않은 변수라도 찾아낼 수 있다.

스코프도 블록처럼 다른 스코프 안에 중첩될 수 있으며, 엔진은 검색 과정에서 대상 변수를 찾을 때까지 바깥쪽 스코프로 하나씩 이동하며 최상위 스코프에 다다를 때까지 검색을 계속한다.

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fz7xDq%2Fbtq8FWbYzSv%2FJUMBmisDaEUxIbJ7XUghQ1%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fz7xDq%2Fbtq8FWbYzSv%2FJUMBmisDaEUxIbJ7XUghQ1%2Fimg.png)

### 참고 자료

[https://velog.io/@jhur98/컴파일러compiler와-인터프리터interpreter의-차이](https://velog.io/@jhur98/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%ACcompiler%EC%99%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0interpreter%EC%9D%98-%EC%B0%A8%EC%9D%B4)

[https://velog.io/@mu1616/컴파일러-이론에서-토크나이저Tokenizer-렉서Lexer-파서Parse-의-역할](https://velog.io/@mu1616/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%9D%B4%EB%A1%A0%EC%97%90%EC%84%9C-%ED%86%A0%ED%81%AC%EB%82%98%EC%9D%B4%EC%A0%80Tokenizer-%EB%A0%89%EC%84%9CLexer-%ED%8C%8C%EC%84%9CParse-%EC%9D%98-%EC%97%AD%ED%95%A0)

[https://lanace93.tistory.com/entry/You-dont-know-JS-Part2-1장-스코프란-무엇인가](https://lanace93.tistory.com/entry/You-dont-know-JS-Part2-1%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)

[https://usage.tistory.com/100](https://usage.tistory.com/100)
