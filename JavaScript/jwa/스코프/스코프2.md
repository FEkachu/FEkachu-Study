# 📍 스코프

## 1. 컴파일러 이론

자바스크립트는 인터프리터 언어이지만, 컴파일 과정을 수행한다. 실제 코드를 수행하기 전에 컴파일러가 언어를 처리하는 과정을 compilation이라고 하며, compilation은 보통 3단계를 거친다.

1. Tokenizing / Lexing

   문자열을 나누어 의미있는 조각을 검출해 토큰을 생성하는 과정.

   ```jsx
   var a = 2;
   ```

   위 코드에서 토큰은 다음과 같다.

   - var
   - a
   - =
   - 2
   - ;

   토큰의 기준은 의미가 있는지 없는지.

   토크나이저와 렉서의 역할을 합하여 Lexical analyze라고 한다.

   토크나이저는 어떤 구문에서 의미있는 요소들을 토큰으로 쪼개는 역할을 하고, 렉서는 토큰의 의미를 분석하는 역할을 한다.

2. Parsing

   Tokenizing 또는 Lexing 과정에서 만들어진 토큰 배열을 가지고 트리 형태로 바꾸는 과정.

   소스코드를 구조적으로 나타내는 자료구조로는 AST(추상 구문 트리)를 사용한다.

   - AST(Abstract Syntax Tree)
     특정 프로그래밍 언어로 작성된 프로그램 소스코드를 각각 의미별로 분리하여 컴퓨터가 이해할 수 있는 구조로 변경시킨 트리.

3. Code generation

   Parsing 과정에서 만들어진 AST를 기반으로 컴퓨터가 실행할 수 있는 기계어로 바꾸는 과정.

   엔진에서 불필요한 요소를 삭제하는 과정을 거쳐 최적화 한다.

   보통 실행 직전에 컴파일 되며 컴파일 시간이 매우 짧다.

## 2. 스코프란?

스코프란 참조 대상 식별자를 찾아내기 위한 규칙이다.

```jsx
var a = 2;
```

- 컴파일 과정
  1. 컴파일러가 `var a` 를 만나면 변수 a가 스코프 안에 있는지 확인한다. 있으면 선언을 무시하고 넘어가지만, 없으면 a라는 이름의 변수를 선언하기를 요청한다.
  2. 다음으로 컴파일러는 대입문 `a = 2;` 를 처리할 수 있는 코드를 생성한다. 코드가 생성이 되면 엔진이 동작한다. 엔진은 현재 스코프에 a 변수가 있는지 확인하고, 있으면 변수를 사용하고 없으면 상위 스코프를 확인한다.
  → **컴파일러**가 변수를 선언하고, **엔진**이 스코프에서 변수를 찾고 대입하는 역할을 한다.

## 3. 컴파일러체

위의 과정 2에서 컴파일러가 생성한 코드를 실행할 때 엔진은 변수가 선언된 적이 있는지 스코프를 탐색한다. 이때 변수를 탐색하는 방법에는 **LHS 검색**과 **RHS 검색** 두 가지가 있다.

- LHS(Left-Hand Side) 검색
  대입되는 변수를 찾기 위해 사용되며, 변수의 값이 담긴 공간을 찾는다. 대입되는 변수는 보통 왼쪽에 위치하므로 Left-Hand 라는 이름이 붙은 것. 위의 코드에서 변수 a를 탐색할 때 LHS 검색이 사용된다.
- RHS(Right-Hand Side) 검색
  변수의 값을 찾는 검색에서 사용된다.
  ```jsx
  // RHS 검색이 사용되는 예시
  console.log(a);
  add(num1, num2);
  str = anotherstr; // str은 LHS, anotherstr은 RHS
  ```

LHS와 RHS는 동작방식의 차이도 있지만, 문제 상황에서 서로 가져오는 결과값이 다르다.

예를 들어 선언되어 있지 않은 변수를 검색하려고 할 때,

**LHS의 경우** 최상위 스코프까지 검색을 마치고도 변수를 찾지 못하면 해당 이름의 **글로벌 변수를 새로 만든다.** 선언하지 않은 변수에 값을 대입할 수 있는 이유도 이러한 엔진의 동작 때문이다.

**RHS의 경우** 검색을 마치고도 변수를 찾을 수 없다면 **Reference Error**를 출력하게 된다.

특수한 경우로 **엄격 모드(Strict Mode)**에서는 글로벌 변수를 암시적으로 생성할 수 없기 때문에 LHS 검색에 실패했을 때도 Reference Error를 출력하게 된다.

- 예제
  ```jsx
  function foo(a) {
    var b = a;
    return a + b;
  }

  var c = foo(2);
  ```
  1. 모든 LHS 검색
     - foo 함수의 parameter a에 값 2를 할당하기 위해 a 검색
     - `var b = a;` 대입을 위해 b 검색
     - `var c = foo(2);` 를 위해 c 검색
  2. 모든 RHS 검색
     - `c = foo(2);` 에서 foo(2)의 값
     - `b = a;` 에서 a의 값 검색
     - `a + b` 를 위해 a 값 검색
     - `a + b` 를 위해 b 값 검색

## 4. 중첩 스코프

엔진이 변수에 값을 대입할 때 현재 스코프에서 변수를 검색하고, 찾지 못하면 중첩 스코프를 찾는다. 우리가 상위에서 선언된 변수나 함수를 사용할 수 있는 것처럼, 엔진은 중첩 스코프 검색을 통해 현재 스코프에 선언되어 있지 않은 변수라도 찾아낼 수 있다.

스코프도 블록처럼 다른 스코프 안에 중첩될 수 있으며, 엔진은 검색 과정에서 대상 변수를 찾을 때까지 바깥쪽 스코프로 하나씩 이동하며 최상위 스코프에 다다를 때까지 검색을 계속한다.

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fz7xDq%2Fbtq8FWbYzSv%2FJUMBmisDaEUxIbJ7XUghQ1%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fz7xDq%2Fbtq8FWbYzSv%2FJUMBmisDaEUxIbJ7XUghQ1%2Fimg.png)

### 참고 자료

[https://velog.io/@mu1616/컴파일러-이론에서-토크나이저Tokenizer-렉서Lexer-파서Parse-의-역할](https://velog.io/@mu1616/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%9D%B4%EB%A1%A0%EC%97%90%EC%84%9C-%ED%86%A0%ED%81%AC%EB%82%98%EC%9D%B4%EC%A0%80Tokenizer-%EB%A0%89%EC%84%9CLexer-%ED%8C%8C%EC%84%9CParse-%EC%9D%98-%EC%97%AD%ED%95%A0)

[https://lanace93.tistory.com/entry/You-dont-know-JS-Part2-1장-스코프란-무엇인가](https://lanace93.tistory.com/entry/You-dont-know-JS-Part2-1%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)

[https://usage.tistory.com/100](https://usage.tistory.com/100)
