# 📍 렉시컬 스코프

## Lexical Scope

스코프는 렉시컬 스코프와 동적 스코프 두 가지 방식으로 작동하는데, 자바스크립트는 렉시컬 스코프를 따른다.

개발자가 코드를 작성할 때 변수를 어디에 작성했는지를 바탕으로 렉스 타임에 스코프가 결정되며, 이때 구성된 스코프를 렉시컬 스코프라고 한다.

함수를 **어디서 선언하였는지**에 따라 스코프가 결정되며, 함수를 어디서 호출하였는지는 스코프 결정에 아무런 영향을 미치지 않는다.

스코프 버블은 스코프 블록이 쓰이는 곳에 따라 결정되는데, 스코프 블록은 서로 중첩될 수 있다.

여러 중첩 스코프 층에 걸쳐 같은 변수 이름을 정의할 수 있으며, 더 안쪽의 확인자가 더 바깥쪽의 확인자를 가리는 것을 섀도잉이라고 한다.

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

foo() 안에서 bar()를 호출했을 때 결과가 1인 이유는, 렉싱 단계에서 스코프 처리를 먼저 하기 때문이다.

foo 스코프, bar 스코프 —(outer)→ 전역 스코프

렉싱 단계에서 foo 스코프와 bar 스코프의 외부 스코프는 전역 스코프라는 것이 결정되므로, bar() 함수가 호출되면 먼저 bar 스코프에서 x 변수를 찾고, 없으면 외부 스코프인 전역 스코프로 가서 변수를 찾게 된다.

### 렉시컬 스코프 수정

런타임 때 렉시컬 스코프를 수정할 수 있으나, 이는 성능을 떨어뜨리는 방법이므로 권장하지 않는다.

- eval  
  eva() 함수는 문자열을 인자로 받아들여 실행 시점에 문자열의 내용을 코드의 일부분처럼 처리한다.

  코드 문자열이 하나 이상의 변수 또는 함수 선언문을 포함하면 eval()이 그 코드를 실행하면서 eval()이 호출된 위치에 있는 렉시컬 스코프를 수정한다.

  ```jsx
  function test(str, a) {
    eval(str);
    console.log(a, b);
  }

  var b = 2;
  test("var b = 3;", 1); // 1, 3
  ```

  렉싱 타임에 결정된 스코프에서는 test 스코프 내에 변수 b가 없었지만 코드를 실행하면서 test 스코프 내에 변수 b가 추가된다.

  eval()은 동적으로 생성된 코드를 실행할 때 사용된다. 하지만 동적으로 생성한 코드를 프로그램에서 사용하는 경우는 굉장히 드물며, 성능 저하를 불러오므로 활용도가 높지 않다.

### 성능

자바스크립트 엔진은 컴파일레이션 단계에서 상당수의 최적화 작업을 진행한다.

최적화의 핵심 작업 중 하나가 렉싱된 코드를 분석하여 모든 변수와 함수 선언문이 어디에 있는지 확인하고 실행 과정에서 확인자 검색을 더 빠르게 하는 것인데, eval()과 with를 사용하는 코드가 있다면 대다수의 최적화가 의미 없어지고 코드가 느리게 동작할 것이다.

## 렉시컬 환경

렉시컬 환경은 명세에서 자바스크립트가 어떻게 동작하는지 설명하는 데 쓰이는 이론상의 객체이다.

렉시컬 환경 객체는 다음의 두 부분으로 구성된다.

- 환경 레코드 : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체
- 외부 렉시컬 환경에 대한 참조

현재 렉시컬 환경의 환경 레코드에서 변수를 찾아보고, 없다면 바깥 렉시컬 환경을 참조하여 찾아보는 식으로 스코프를 탐색한다. 이 중첩 스코프 탐색은 해당 변수를 찾거나 바깥 렉시컬 환경 참조가 `null`이 될 때 탐색을 멈춘다.

![https://image.toast.com/aaaadh/alpha/2016/techblog/scopchain.png](https://image.toast.com/aaaadh/alpha/2016/techblog/scopchain.png)

### 함수를 반환하는 함수

```jsx
function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

`makeCounter()`를 호출하면 새로운 렉시컬 환경 객체가 만들어지고 여기에 `makeCounter`를 실행하는 데 필요한 변수들이 저장된다. (중첩 함수는 생성만 되고 실행은 되지 않은 상태이다.)

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.

따라서 `counter.[[Environment]]`에는 `{count: 0}`이 있는 렉시컬 환경에 대한 참조가 저장된다.

**호출 위치와 상관없이 함수가 자신이 생성된 곳을 기억할 수 있는 것은 바로 이 `[[Environment]]` 프로퍼티 덕분이다.** `[[Environment]]` 프로퍼티는 함수가 생성될 때 값이 세팅되고 그 후 변하지 않는다.

따라서 중첩 함수의 `return count++` 가 실행되면 먼저 자체 렉시컬 환경에서 count 변수를 찾는다. 익명 중첩 함수의 렉시컬 환경은 비어있기 때문에 counter()의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 count 변수를 찾게 된다.

`count++` 가 실행되면서 변수 값이 갱신되는 것은 변수가 저장된 렉시컬 환경에서 이루어진다. 따라서 `counter()` 를 호출할 때마다 `count` 변수가 1씩 증가하게 된다.

### 참고 자료

렉시컬스코프  
https://olaf-go.medium.com/%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-ef3c8e8584d4  
https://watermelonlike.tistory.com/123  
렉시컬 환경  
https://meetup.toast.com/posts/86  
https://ko.javascript.info/closure
