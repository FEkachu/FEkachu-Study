# 📍 자바스크립트의 동작 환경

모든 브라우저는 자바스크립트 코드를 해석하고 실행할 수 있는 엔진을 내장하고 있다. 브라우저 뿐만 아니라 Node.js도 자바스크립트 엔진을 내장하고 있다. 따라서 자바스크립트는 **브라우저와 Node.js 환경**에서 실행할 수 있다.

## 브라우저와 Node.js

- 브라우저 : HTML, CSS, 자바스크립트를 실행하여 웹 페이지를 화면에 렌더링하는 것이 주목적
- Node.js : 서버 개발 환경을 제공하는 것이 주목적

브라우저와 Node.js 모두 ECMAScript를 실행할 수 있지만 그 외에 추가적으로 제공하는 기능은 호환되지 않는다.

예를 들어 브라우저는 HTML 요소를 선택하거나 조작하는 기능들의 집합인 DOM API를 기본적으로 제공하지만, 서버에서는 HTML 요소를 다룰 일이 없기 때문에 Node.js는 DOM API를 제공하지 않는다.

반대로 Node.js에서는 파일을 생성하고 수정하는 File 시스템을 기본으로 제공하지만 브라우저는 이를 지원하지 않는다. 브라우저는 사용자 컴퓨터에서 작동하기 때문에 브라우저를 통해 파일 생성/수정이 가능하다면 사용자 컴퓨터가 악성 코드에 노출되기 쉬워 보안 상의 이유로 금지하는 것이다.

이처럼 브라우저는 클라이언트 사이드 ECMAScript와 Web API를 지원하며, Node.js는 ECMAScript와 Node.js 고유의 API를 지원한다.

## 자바스크립트 실행 환경

그렇다면 자바스크립트는 어떤 환경이 갖춰져야 동작이 가능한 걸까?

![https://blog.kakaocdn.net/dn/bREdmQ/btq3nBEgBmI/00k7kyyWItbCnnCjrUUXvk/img.png](https://blog.kakaocdn.net/dn/bREdmQ/btq3nBEgBmI/00k7kyyWItbCnnCjrUUXvk/img.png)

자바스크립트 코드는 특정한 실행환경이 갖춰져야 동작이 가능하다.

- 자바스크립트 엔진
- Web API / Node API
- callback 큐
- 이벤트 루프

### 자바스크립트 엔진

자바스크립트 엔진은 자바스크립트 코드를 읽고 실행시키는 프로그램이다.

자바스크립트 엔진에는 코드를 실행하는데 필요한 **메모리 힙**과 **콜 스택**이 같이 들어있다. **메모리 힙**에는 non-primitive 타입의 데이터가 저장되고, **콜 스택**에는 함수 호출 시 생성되는 **실행 컨텍스트**가 stack 형태로 쌓이며 저장된다.

실행 컨텍스트에는 함수의 argument, 함수에서 선언한 변수 등 함수가 실행되면서 필요한 정보가 저장되며, 함수 호출 시 생성되고 함수가 종료되면 사라진다. 자바스크립트 엔진은 콜 스택의 제일 위에 있는 함수부터 하나씩 실행한다.

### Web API / Node API

DOM 객체나 setTimeout 같은 함수들은 자바스크립트 언어 자체에서 지원하는 기능이 아닌, 자바스크립트 실행환경에서 제공하는 기능이다. 브라우저 환경에서는 Web API가, node.js 환경에서는 Node API가 제공된다.

### callback Queue

콜백 큐는 콜백 함수들이 실행되기 전에 대기하는 공간이다. 콜백 함수들은 콜백 큐에서 대기하다가 콜 스택이 비게 되면 하나씩 쌓여 실행된다.

### 이벤트 루프

이벤트 루프는 **콜백 큐와 콜 스택을 주시**하며 콜백 큐에서 대기 중인 콜백 함수를 콜 스택이 비었을 때 콜 스택에 쌓아주는 역할을 한다.

---

모든 브라우저는 위 네 가지 구성 요소가 내장되어 있어서 자바스크립트 코드를 실행할 수 있는 것이다. Node.js는 브라우저 밖에서도 자바스크립트 코드를 실행할 수 있도록 위 네 가지 구성요소를 브라우저 밖에 구현해놓은 실행환경이다. 다만, node.js는 브라우저에서 필요한 Web API 대신 Node API 를 제공한다.

## 자바스크립트 동작 방식

자바스크립트 코드가 동작하기 위해 이런 실행 환경을 갖추고 있어야 하는 이유는 자바스크립트가 **single thread에서 동작하는 언어**이기 때문이다. 즉, 하나의 콜 스택만 가지고 있으며 한 번에 한 가지 일만 처리할 수 있다. 그렇지만 자바스크립트가 처리하는 브라우저의 이벤트는 한 번에 한 가지씩만 발생하지 않기 때문에 **single thread로 비동기적으로 발생하는 이벤트를 처리**할 수 있어야 한다.

이를 위해 등장한 것이 **콜백 함수**이다. 자바스크립트에서는 비동기 처리가 필요한 경우 콜백 함수를 받고 그 함수들은 콜백 큐에서 대기한다. 그리고 이벤트 루프가 자바스크립트 코드 내의 모든 동기 함수들의 처리가 끝난 후 콜 스택이 비면 콜백 큐에서 대기 중인 콜백 함수들을 하나씩 콜 스택에 쌓아준다. 이런 방식을 통해 자바스크립트는 싱글 스레드를 이용하여 비동기 이벤트를 처리한다. 이런 일들은 매우 빠르게 일어나기 때문에 여러 비동기적인 이벤트들을 동시에 처리하는 것처럼 보이게 된다.

## 💡 7/5 스터디 내용 추가

### 비동기 함수를 처리하는 방식 (브라우저 vs node.js)

- 브라우저

  - 브라우저에서 사용할 수 있는 비동기 흐름 : 타이머 혹은 DOM 이벤트와 관련된 상황
    ![https://blog.kakaocdn.net/dn/bREdmQ/btq3nBEgBmI/00k7kyyWItbCnnCjrUUXvk/img.png](https://blog.kakaocdn.net/dn/bREdmQ/btq3nBEgBmI/00k7kyyWItbCnnCjrUUXvk/img.png)

  ```jsx
  setTimeout(function cb1() {
    console.log(1);
  }, 0);

  console.log(2);

  setTimeout(function cb2() {
    console.log(3);
  }, 0);

  // 2
  // 1
  // 3
  ```

  1. 먼저, cb1() 함수를 콜백 함수로 받은 setTimeout(cb1, 0)이 호출되어 콜 스택에 쌓인다.
  2. 콜 스택에 쌓인 setTimeout(cb1, 0) 함수가 실행되면 Web API에 있는 timer가 지연시간만큼 콜백함수를 대기시킨다. 지연시간이 0ms이더라도 아주 잠깐 대기 후에 콜백 큐에 들어가게 된다.
  3. 다음으로 console.log(2)가 호출되어 콜 스택에 쌓이고, 실행되면 콘솔에 2가 출력되고 콜 스택에서 제거된다.
  4. 다음으로 cb2() 함수를 콜백으로 받은 setTimeout(cb2, 0)이 콜 스택에 쌓인다.  
     ※ 콜 스택에서 console.log(2)가 제거되고 setTimeout(cb2, 0)이 들어오기 전 콜 스택이 잠시 비어있게 되지만, 새로 들어오는 함수의 우선순위가 더 높기 때문에 콜백 큐에서 대기 중인 함수들은 더이상 새로 들어오는 함수가 없을 때까지 대기해야 한다.
  5. setTimeout(cb2, 0) 함수가 실행되면 마찬가지로 timer가 0ms만큼 cb2를 대기시키고 지연시간이 끝나면 cb2는 콜백 큐로 들어가게 된다.
  6. 더이상 콜 스택에 새로 들어오는 함수가 없고, 콜 스택이 비었기 때문에 이제 콜 스택 큐에서 대기 중이던 콜백 함수들이 차례대로 콜 스택에 쌓인다.
  7. 제일 처음 콜백 큐로 들어왔던 cb1() 함수가 콜 스택에 쌓이고, cb1() 함수 내부에서 호출한 console.log(1) 함수도 이어서 콜 스택에 쌓인다.
  8. console.log(1) 함수와 cb1() 함수가 종료되어 콜 스택에서 제거되면 다시 콜 스택이 비게 되고, 이어서 콜백 큐에서 대기 중이던 cb2() 함수가 콜 스택에 쌓인다.
  9. cb2() 함수 내부에서 호출한 console.log(3) 함수도 이어서 콜 스택에 쌓이고 두 함수가 종료되어 콜 스택에서 제거되면 자바스크립트 코드의 실행이 종료된다.

  ➡️ 자바스크립트에서는 비동기 처리가 필요한 경우 **콜백 함수**를 받고 그 콜백 함수들은 **콜백 큐**에서 대기한다. 그리고 **이벤트 루프**가 자바스크립트 코드 내의 모든 동기 함수들의 처리가 끝난 후 **콜 스택이 빈 것을 확인하면 콜백 큐에서 대기 중인 콜백 함수들을 하나씩 콜 스택에 쌓아준다.** 이러한 방식을 통해 자바스크립트는 싱글 스레드를 이용하여 비동기 이벤트들을 처리한다. 자바스크립트는 동시에 한 가지 일만 진행할 수 있지만 이런 과정들이 매우 빠르게 일어나기 때문에 여러가지 비동기적인 이벤트들을 동시에 처리하는 것처럼 보이게 된다.

- Node.js
  Node.js는 비동기 IO를 지원하며 싱글 스레드 기반으로 동작하는 서버이다.
  ![https://www.nextree.co.kr/content/images/2021/01/syhan_140320_node1_041.png](https://www.nextree.co.kr/content/images/2021/01/syhan_140320_node1_041.png)
  Node.js의 비동기 처리는 이벤트 방식으로 풀어낸다. 클라이언트의 요청을 비동기로 처리하기 위하여 이벤트가 발생하며, 서버 내부에 메시지 형태로 전달된다. 서버 내부에서는 이 메시지를 이벤트 루프가 처리하며, 그동안 제어권은 다음 요청으로 넘어간다. 요청 처리가 완료되면 콜백을 호출하여 처리 완료를 호출 측에 알린다.
  이벤트 루프에서 처리되는 작업이 긴 시간을 요구하는 경우 전체 서버의 성능이 저하되므로, 이런 경우 전달할 이벤트를 작은 단위로 쪼개어 병렬로 처리될 수 있게 유도해야 한다. 일반적으로 병렬 처리 시에는 count를 이용한 패턴을 자주 사용한다. (callback이 전달된 횟수만큼 count에 저장, 작업 완료될 때마다 하나씩 감소)

  ```jsx
  var fs = require("fs");

  fs.readdir(".", function (err, filenames) {
    var i;
    for (i = 0; i < filenames.length; i++) {
      console.log(filenames[i]);
    }
    console.log("ready");
  });

  console.log("can process next job...");
  ```

  비동기 API의 마지막 인자로 콜백 함수가 전달되고, 전달된 콜백 함수는 디렉토리를 읽는 작업이 완료된 후 호출된다.
  콜백 함수 내의 ‘ready’ 메시지보다 밖의 ‘can process next job…’ 메시지가 먼저 출력된다. 이는 File System의 비동기 API를 사용했기 때문이다.

### 참고 자료

브라우저 동작 환경 [https://wookgu.tistory.com/21](https://wookgu.tistory.com/21)

Node.js 비동기 처리 [https://www.nextree.co.kr/p7292/](https://www.nextree.co.kr/p7292/)

동기/비동기 [https://velog.io/@sominpark/Node.js와-비동기-흐름의-기본-이해-bhggcztf](https://velog.io/@sominpark/Node.js%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%9D%90%EB%A6%84%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%ED%95%B4-bhggcztf)
