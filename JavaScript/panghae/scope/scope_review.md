### 

## Scope란 무엇인가?

- 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는데에 쓰일 잘 정의된 규칙이 필요하다. 이를 스코프라고 한다.
- 참조 대상 식별자(Identifier: 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분해 식별할 수 있는 유일한 이름)을 찾아내기 위한 규칙이다.

## Scope의 종류

1. Lexical Scope : 정적 스코프 → 함수나 변수가 선언된 위치에 관심을 두는 Scope. 함수가 선언된, 즉 Compile 시에 결정되는 Scope를 말한다.
2. Dynamic Scope : 동적 스코프 → 함수나 변수가 호출된 위치에 관심을 두는 Scope. 함수가 호출된, 즉 Runtime에 결정되는 Scope를 말한다.

Dynamic Scope를 채택한 언어로는 bash, LaTeX 등이 있는데 bash 외에는 들어본 적이 없다.

JS는 Lexical Scope를 채택한 언어이다. 이 말은 Compile 과정을 가진다는 의미로 해석이 가능한데, Javascript는 익히 인터프리터 언어로 유명한 언어이다. 이게 뭘까?

## Compile vs Interpreter

- 컴파일은 우리가 작성한 소스 코드를 오브젝트 코드로 변환시키는 과정을 의미한다. 컴파일 언어는 실행에 들어가기에 앞서 기계 언어로 미리 바꿔두기 때문에, 런타임 환경에서 매우 빠르게 동작한다. 컴파일 시간이 소요되지만, Syntax Error나 Type Error를 감지해 실제 동작에서 예상치 못한 에러를 마주할 일이 적다.
- 인터프리터 언어는 실행과 동시에 한 줄 씩 중간 언어로 해석한 다음에 실행한다. 별도의 컴파일 과정 없이 고급 언어를 바로 실행할 수 있어 변경 사항을 빠르게 테스트하기 좋고, 대화식으로 사용이 가능하다.

### Javascript는 인터프리터 언어인가?

- 자바스크립트는 실질적으론 컴파일이 되지만, 편의 및 문맥상 인터프리터 언어로 분류된다. 모던 자바스크립트 컴파일러는 `runtime 내에서 빠르게 컴파일(Just In Time Compilation)`을 수행한다.
- 자바스크립트의 목적은 웹 문서 구조를 동적으로 나타내기 위함이다. 이 때문에 목적에 맞게 인터프리터 언어로 만들어졌는데, 유저와 상호작용이 많아지면서 빠른 시간 내에 웹 페이지를 띄우고자 하는 수요가 많아졌다.
- 2009년에 등장한 구글의 V8 엔진은 필요에 따라 컴파일 과정을 거쳐서 자바스크립트의 실행 성능을 높이는 방식을 사용한다. → 런타임 환경에서 가장 많이 발생하는 브라우저의 작업은 변수, 객체, 함수 등의 메모리 상에서 위치를 탐색하는 작업이다.

[JS 성능 비교](https://12bme.tistory.com/134)

### Compile 과정

1. 토크나이징(Tokenizing)/렉싱(Lexing)

   문자열을 나눠 ‘토큰’이라고 불리는 가장 작은 단위의 의미 있는 조각으로 만드는 과정이다. 이때 ‘토크나이저’가 상태 유지 파싱 규칙을 적용해 토큰과 토큰 간의 관계를 파악한다면 렉싱이라고 부른다.

2. 파싱(parsing)

   토큰 배열을 프로그램의 문법 구조를 반영해 중첩 원소를 갖는 트리 형태로 바꾸는 과정을 말한다.

   → 파싱의 결과로 생성되는 트리를 AST(Abstract Syntax Tree) 추상 구문 트리라고 부른다.

   ### AST?

   프로그래밍 언어의 문법에 따라 소스 코드 구조를 표시하는 계층적 프로그램 표현을 말한다. AST의 노드는 소스 코드의 항목에 해당한다.

    ```jsx
    function square(n){
    	return n * n;
    }
    // 아래와 같으 구조를 가진다. 
    // {
    	// type : "FunctionDeclaration",
    	// id: {
    	// type : "Identifier",
    	// name : "square"
    	// },
    	// params : [
    		// {
    			// type : "Identifier",
    			// name : "n"
    		// }
    	// ],
    		// body: [
    			// type : "BlockStatement",
    			// body : [
    				// {
    					// type : "ReturnStatement",
    					// argument: {
    						// type : "BinaryExpression",
    						// operator: "*",
    						// ...
    ```

   [자바스크립트 개발자를 위한 AST(번역)](https://gyujincho.github.io/2018-06-19/AST-for-JS-devlopers)

3. 코드 생성

   AST를 컴퓨터에서 실행 코드로 바꾸는 과정을 말한다.

## 스코프 검색 및 실행 과정

### LHS(Left-Hand-Side), RHS(Right-Hand-Side) 검색

컴파일러가 생성한 코드를 실행할 때, 엔진은 변수가 선언된 적이 있는지 스코프에서 검색한다. 이 때, 엔진이 어떤 종류의 검색을 하는지에 따라 검색 결과가 달라진다.

- LHS 검색 → 대입 연산자의 왼쪽에 있을 때 실행한다.

  값을 대입해야하기 때문에 변수 컨테이너를 찾는 검색이다.

- RHS 검색 → 대입 연산자의 오른쪽(왼편이 아닌 쪽)에 있을 때 실행한다.

  단순히 특정 변수의 값을 찾는 검색이다.

## 중첩 스코프

하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로 스코프도 다른 스코프 안에 중첩될 수 있다.

중첩 스코프를 탐사하는 규칙은

1. 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계 씩 올라간다.
2. 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

## 렉시컬 스코프

### 렉스타임?

lex라는 것은 token을 합쳐 의미를 가지는 단위로 변경할 때 lexing이라는 과정을 거쳐서 생성되는 산출물이다. 이 과정이 일어나는 시간을 렉스 타임이라고 하는데, 렉시컬 스코프는 렉싱 타임에 정의 되는 스코프를 의미한다. → 코드를 짤 때, 변수와 스코프 블록을 어디서 작성하는가를 기반으로 lexer가 코드를 처리할 때 확정된다.

### 확인자 검색

엔진은 스코프 버블의 구조와 상대적인 위치를 통해서 어디를 검색해야 확인자를 찾을 수 있는지 안다. 가장 안 쪽 스코프에서 바깥 스코프로 이동하면서 검색하는 대상을 발견하면 즉시 중단한다. 중단하기 전까지는 안에서 바깥 스코프로 이동하는 동작을 계속해서 반복한다.

→ `Shadowing` : 여러 중첩 스코프 층에 걸쳐 같은 확인자 이름을 사용해 정의하는 것을 의미한다. 잠시 상위 스코프의 변수를 가려주는 역할을 한다.

```jsx
var wow = 'wow';

function woow(){
	var wow = 'hello';
	console.log(wow);
}

woow(); // hello
console.log(wow); // wow
```

## 렉시컬 속이기

- eval

  eval() 함수는 문자열을 인자로 받아들여 실행 시점에 문자열 내용을 코드 일부분처럼 처리하는 기능을 한다. → eval()이 호출된 위치의 렉시컬 스코프를 수정한다. 렉시컬 스코프를 런타임에 수정할 수 있게 되는 것이다.

  but 동적으로 코드를 생성해서 사용하는 경우가 매우 적고, 사용할 때 성능 저하가 일어나 사용을 지양한다. 또한 보안적으로 좋지 않아 절대 사용하지 않도록 강조하고 있다.

  [eval() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/eval#eval%EC%9D%84%20%EC%A0%88%EB%8C%80%20%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80%20%EB%A7%90%20%EA%B2%83)


JS엔진은 컴파일 단계에서 최적화 작업을 진행한다. 이 때의 핵심은 렉싱된 코드를 분석하여 선언문의 위치를 파악해 실행 시에 검색을 빠르게 수행하도록 도와준다. 이를 런타임에 렉시컬 스코프를 수정하게 되면 컴파일 단계에서 일어난 최적화가 무의미해진다.

## 함수 vs 블록 스코프

### 함수 스코프

```jsx
function hello(){
  const a = 2;
  function wow(){
    var b = 1;
    return console.log(b);
  }
	wow();
}

hello();
console.log(a); // ReferenceError
console.log(b); // ReferenceError
```

이 코드에서 hello의 scope에 속하는 확인자는 a, wow이다.
wow의 scope에 속하는 확인자는 b이다.
global scope에 속하는 확인자는 hello, a, b가 있다.

global scope에서 콘솔을 찍어보면 a,b 모두 접근이 불가능한데, 왜냐하면 global scope에 a,b 확인자가 없기 때문이다.

**함수 스코프는 모든 변수가 함수에 속하고, 함수 전체에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다.**

but 스코프 전체 범위에서 변수가 살아 있다는 점이 예상치 못한 문제를 발생 시키는 경우가 있다.

### 일반 스코프에 숨기

보통 함수를 선언하고 함수 내부에 코드를 넣는다라고 생각하는데 다르게 생각해보면, 코드를 작성하고 함수로 감싸서 스코프 안에 코드를 숨긴다고도 말할 수 있다.

스코프를 이용해 숨기는 방식은 소프트웨어 디자인 원칙인 ‘최소 권한의 원칙'과 연관된다.

- 최소 권한의 원칙
    - 모듈 / 객체의 API 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 ‘숨겨야'한다는 것.
- 충돌 회피
    - 같은 이름을 가졌지만, 다른 용도를 가진 두 확인자의 충돌을 회피하는 기능.
    - 이름은 겹치지 않도록 사용하는게 가장 좋다.
- 글로벌 ‘네임스페이스’
    - 내부/비공개 함수와 변수가 적절하게 숨겨져 있지 않은 라이브러리를 한 프로그램에서 불러올 시, 쉽게 충돌할 수 있다.
    - 이럴 경우, 글로벌 스코프에 고유의 이름을 가지는 객체 선언문을 생성한다.
- 모듈 관리
    - 확인자를 글로벌 스코프에 추가할 필요없이, 특정 스코프로부터 의존성 관리자를 이용한 다양한 방법으로 확인자를 가져와 사용할 수 있다.

  [JS 의존성 관리 - 모듈 시스템과 NPM - Tlog](https://tlog.tammolo.com/posts/js-module-npm)

  [자바스크립트 의존성 관리자(npm, yarn, pnpm)에서 보다 더 의존성 관리 잘하는 방법](https://yceffort.kr/2021/07/javascript-dependency-manager-dont-mange-dependencies)


### 스코프 역할을 하는 함수

- 함수 표현식 vs 함수 선언식

    ```jsx
    function sum(a,b){
    	return a + b;
    } // 함수 선언식
    
    const sum = function (a,b){
    	return a + b;
    } // 함수 표현식
    ```

  중요한 차이는 호이스팅 되는 방식이다.
  함수 선언식은 변수 선언, 메모리 할당, 변수 대입이 모두 일어나기 때문에 함수가 선언되기 이전에도 함수를 사용할 수 있다.

  함수 표현식은 좌측에 존재하는 **var, let, const**에 따라 호이스팅되는 방식이 결정된다.

  함수 선언식은 익명으로 사용이 불가능하지만, 함수 표현식은 익명으로 사용이 가능하다.

  [함수 선언식 과 함수 표현식 차이점](https://taenami.tistory.com/86)

  [](https://velog.io/@d159123/12.-%ED%95%A8%EC%88%98)

    - 익명 함수 단점
        - 익명 함수는 스택 추적 시, 표시할 이름이 없어 디버깅이 어려울 수 있다.
        - 익명 함수 스스로 재귀 호출을 위해선 arguments.callee(사라질 예정)를 참조해야한다.
        - 이름이 없는 함수는 코드를 읽을 때, 어려움이 있을 수 있다.
- IIFE(Immediately Invoked Function Expression) 즉시 호출 함수 표현식

    ```jsx
    (function hello(){
    	console.log('hello')
    })(); // hello
    ```

    - 언제 사용하는가?
        - 한 번만 실행을 필요하는 초기화 코드 부분에서 많이 사용한다.
    - 사용하는 이유?
        - 변수를 전역으로 선언하는 것을 피하기 위해서, 전역에 변수를 선언하지 않아도 되기 때문에 코드 충돌 없이 구현이 가능하다. → 주로 라이브러리나 플러그인 작성시 많이 사용한다.

  [즉시 실행 함수(IIFE)에 대한 정리](https://velog.io/@tlatjdgh3778/%EC%A6%89%EC%8B%9C-%EC%8B%A4%ED%96%89-%ED%95%A8%EC%88%98IIFE%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC)


### 스코프 역할을 하는 블록

- 블록 스코프의 목적
    - 변수를 최대한 사용처 가까이에서 최대한 작은 유효 범위를 갖도록 선언하도록 하기 위해서 사용한다.
    - 블록 스코프를 통해 필요가 없는 변수들을 가비지 콜렉팅해 메모리 효율을 높일 수 있다.
- 블록 스코프 인식하는 구문들
    - var는 함수를 제외한 블록들을 스코프로 인식하지 않는다.

        ```jsx
        try{
          var a = 1;
          throw ReferenceError;
        }catch(e){
          var b = 2;
        }
        console.log(a); // 1
        console.log(b); // 2
        
        ---
        
        if(true){
          var j = 1;
        }
        console.log(j); // 1
        
        ---
        
        for(var i =0; i < 10; i++){
         // ~~
        }
        console.log(i);// 10
        
        ---
        
        function hello(){
        	var a = 1;
        }
        
        cosnole.log(a); // error
        ```

    - let, const는 블록을 스코프로 인식한다.

        ```jsx
        {
          let a = 1;
        }
        console.log(a); // error
        ```