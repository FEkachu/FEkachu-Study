## 캐시

---

웹 사이트와 애플리케이션의 성능은 이전에 가져온 리소스들을 재사용함으로써 현저하게 향상될 수 있다. 

웹 캐시는 레이턴시(request와 response 사이의 시간을 의미)와 네트워크 트래픽을 줄여줌으로써 리소스를 보여주는데 필요한 시간을 줄여준다. 
→ 웹사이트가 좀 더 빠르게 반응하도록 만들 수 있다. 

### 캐싱이란?

캐싱이란 주어진 리소스의 복사본을 저장하고 있다가 요청 시에 복사본을 제공하는 기술을 말한다. 

### 캐싱으로 얻는 이점

1. 접속한 모든 클라이언트를 서비스할 필요가 없어지므로 서버의 부하를 완화할 수 있다.
2. 캐시가 원래 서버에 비해서 가까운 곳에 있기 때문에 성능이 향상된다. → 응답속도가 빨라진다.

### 캐싱을 사용할 때 주의할 점

모든 리소스가 영원히 변하지 않는 것이 아니기 때문에 리소스가 변하기 전까지만 캐싱하고 이후에 더 이상 캐싱하지 않는 것이 중요하다.

### 캐시의 종류

사설(private), 공유(shared) 캐시 두 가지 부류로 분류가 가능하다.

- 공유 캐시
    
    공유 캐시는 한 명 이상의 사용자가 재사용이 가능하도록 응답을 저장하는 캐시를 말한다. 
    
    예시로 ISP(Internet Service Provider)가 소유한 프록시 서버에 저장된 캐시를 의미한다. 
    → 한국 유저가 넷플릭스를 보기 위해서는 미국 서버에 접속해야하는데 이를 개선하기 위해 한국 ISP인 SKT, KT, LGU+ 등에 프록시 캐시 서버를 설치해 한국 유저들이 더 나은 환경에서 이용할 수 있도록 하는 일
    → 조회가 많이되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시를 줄여준다.
    
- 사설 캐시
    
    사설 캐시는 한 명의 사용자만 사용하는 캐시를 말한다. 
    
    브라우저 캐시는 그 사용자에 의해 HTTP를 통해 다운로드된 모든 문서들을 가지고 있다. 이 캐시는 서버에 대한 추가적인 요청 없이 뒤로가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용할 수 있게 해준다. 또한 유사한 방법으로 캐시된 컨텐츠의 오프라인 브라우징을 개선시킨다.
    
    - 오프라인 브라우징
        
        오프라인(인터넷 연결이 없을 때)일 때 캐시를 사용하여 이미 방문한 웹페이지를 보는 것이 가능하다. 
        

### 캐싱의 동작 대상

HTTP 캐시들은 일반적으로 GET에 대한 응답만을 캐싱한다. 

기본 캐시 키(primary cache key)는 요청 메서드 그리고 대상 URI로 구성된다. (GET 요청만을 대상으로 해서 URI만 사용하는 경우가 많다.)

- 캐싱 엔트리 형태
    - 요청에 대한 결과  : GET 요청에 대한 200(ok) 응답
    - 영구적인 다이렉트 : 301 응답
    - 오류 응답 : 404 결과 페이지
    - 완전하지 않은 결과 : 206
    - 캐시키로 사용하기에 적절한 무언가가 정의된 경우의 GET 이외의 응답

### 캐싱 제어

### Cache-control 헤더

HTTP/1.1 기본 헤더 필드는 요청과 응답 양측에 어떤 캐싱 메커니즘을 사용할 것인지 지정하는데 사용된다.

- 캐시하지 않음
    
    요청이 매번 서버 측으로 전송되고 전체 응답은 매번 다운로드 된다.
    
- 캐시하지만 재검증
    
    캐시된 복사본을 사용자에게 주기 이전에 유효성 확인을 위해 원 서버로 요청을 보낸다.
    
- 사설 캐시, 공개 캐시 설정
    
    `Cache-Control : public` 으로 설정 시, 응답이 공유 캐시, 사설 캐시 무엇이든 캐싱할 수 있다는 것을 의미한다. 
    
    `Cache-Control : private` 으로 설정 시, 단일 사용자만을 위한 것이고 공유 캐시는 캐싱하지 않는다는 것을 의마한다. 사설 브라우저 캐시는 이 경우에 응답을 저장할 수 있다.
    
- 만료
    
    `Cache-Control : max-age=<seconds>` 로 리소스가 유효하다고 판단되는 최대 시간을 설정할 수 있다. 
    
    `Expires`가 설정되어 있어도 그보다 우선시 한다.
    
    - Expires
        
        응답이 더 이상 신선하지 않다고 판단할 날짜/시간을 의미한다. 
        
        ```
        Expires: Wed, 21 Oct 2015 07:28:00 GMT
        ```
        
- 검증
    
    `Cache-Control : must-revalidate` 는 오래된 리소스를 사용하기 전에 그 상태를 확인하고 만료된 리소스는 사용하지 말아야 한다는 의미이다.
    
    캐시 검증은 문서의 만료 시간이 가까워져오면 문서가 검증되거나 다시 불러오게 되는데, 서버가 강한 검증 혹은 약한 검증 중 하나라도 제공하는 경우에만 일어날 수 있다. 
    
    재검증은 사용자가 리로드 버튼을 누를 경우에 일어난다. `Cache-Control : must-revalidate` 헤더를 포함하고 있는 경우에는 일반적인 브라우징에서도 일어날 수 있다. 
    

[HTTP caching - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)

## 쿠키

HTTP 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 브라우저는 해당 데이터 조각을 저장해놓았다가, 동일한 서버에 재 요청 시 저장된 데이터와 함께 전송한다. 
→ 주로 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용된다. 

### 쿠키의 사용 목적

- 세션 관리 (Session Management)
    - 서버에 저장해야 할 로그인, 장바구니, 스코어 등의 정보를 관리할 수 있다. (자동로그인, 쇼핑몰 장바구니)
- 개인화 (Personalize)
    - 서비스에서 사용자가 커스터마이징 할 수 있는 정보나 테마 등의 세팅값을 쿠키에 저장할 수 있다.(오늘 더 이상 팝업 보지 않기)
- 트래킹 (Tracking)
    - 서비스에서 사용자의 행동 정보를 기록할 수 있다. (한 번 누른 좋아요 버튼 더 못 누르게 하기)

과거엔 클라이언트 측에 정보를 저장할 때 쿠키를 주로 사용했다. 현재는 Modern Storage API(Local Storage, Session Storage, IndexedDB)를 사용해 정보를 저장하는 것을 권장한다. 

### 쿠키 만들기

HTTP response 시, 서버에서 `Set-Cookie` 헤더를 전송할 수 있다. 이 쿠키는 주로 브라우저에 저장이 되고, 그 후 쿠키는 같은 서버에서 만들어진 요청들의 Cookie HTTP 헤더 안에 포함되어 전송된다. 

1. 서버에서 생성한 쿠키를 Client로 전송
    
    ```
    Set-Cookie : <cookie-name>=<cookie-value>
    ```
    
2. Client에서 수신한 정보를 브라우저에 저장
    
    ```
    HTTP/1.0 200 OK
    Content-type: text/html
    Set-Cookie: yummy_cookie=choco
    Set-Cookie: tasty_cookie=strawberry
    ```
    
3. 저장된 쿠키를 모든 요청의 Cookie 헤더에 담아 request 전송
    
    ```
    GET /sample_page.html HTTP/1.1
    Host: www.example.org
    Cookie: yummy_cookie=choco; tasty_cookie=strawberry
    ```
    

### 쿠키의 라이프타임

- 세션 쿠키(Session Cookie)는 현재 세션이 끝날 때 삭제된다. 브라우저는 ‘현재 세션’이 끝나는 시점을 정의하고, 어떤 브라우저들은 재시작할 때 세션을 복원해 세션 쿠키가 무기한 존재할 수 있도록 한다.
- 지속 쿠키(Persistent Cookie)는 Expires 속성에 명시된 날짜 혹은 Max-Age속성에 명시된 기간 이후에 삭제된다.
    
    ```
    Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
    ```
    

### Secure Cookie와 HttpOnly Cookie

- Secure Cookie : HTTP 프로토콜 상에서 암호화된 요청일 경우에 전송된다. but 민감한 정보는 절대 쿠키에 저장x, 본질적으로 안전한 데이터가 아니고 Secure 플래그가 실질적인 보안을 제공하지 않기 때문이다.
- HttpOnly Cookie : JS Document.cookie API에 접근이 불가능하다. 서버에 only 전송되는 용도이다.

[HTTP 쿠키 - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)

[[네트워크] HTTP 쿠키와 세션이란 ?](https://noahlogs.tistory.com/38)

[[쉬운설명] HTTP 쿠키(Cookie)에 대한 설명!!](https://chobopark.tistory.com/232)