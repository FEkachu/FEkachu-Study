- JavaScript 문법

  ### 문과 표현식

    - 문은 실행 가능한 최소의 독립적인 코드 조각을 얘기한다.
        - 한 개 이상의 표현식이나 프로그래밍 키워드를 포함하는 경우가 많다.

            ```jsx
            for (let i = 0; i < 10; i++) {} // for statment
            
            while (true) {} // while statment
            
            if (true) {} // if statment
            
            let a; // declaration statment
            
            function b() {} // function declaration statement
            ```

    - 표현식은 특정한 결과값으로 계산되는 것

        ```jsx
        let a = 3 * 6; // 1
        let b = a; // 2
        b; // 3
        ```

        1. `3 * 6`은 18로 평가되는 표현식이고, `let a = 3 * 6;`은 변수를 선언하기 때문에 선언문이라고 한다.
        2. `let b = a;` 문도 변수를 선언하기 때문에 선언문이라고 한다.
        3. `b`가 표현식의 전부 이지만 완전한 문이다. 이런 문을 표현식 문이라고 부른다.

  ### 문의 완료 값

  모든 문은 완료 값을 가진다. 개발자 도구에 타이핑해보면 쉽게 볼 수 있다.

    ```jsx
    let a = 0;
    // undefined
    let b = 1;
    // undefined
    if(true){
    	a = 2+38;
    }
    // 40
    ```

  보통의 { } 블록은 내부의 가장 마지막 문/표현식의 완료 값을 자신의 완료값으로 반환한다.

  ### 표현식의 부수 효과

  대부분의 표현식에는 부수 효과가 없다. 함수 호출 표현식은 부수 효과를 가진 표현식의 예이다.

    ```jsx
    let a = 0;
    
    function foo(){
    	a = a + 1;
    }
    
    foo(); // 결과값 : 'undefined', 부수 효과 : a의 값이 변경됨
    ```

    - ++의 부수 효과

      ++a와 a++

        ```jsx
        let a = 42;
        
        a++; // 42
        a; // 43
        
        ++a; // 44
        a; // 44
        ```

      전위 연산자로 사용하면 표현식으로부터 값이 반환되기 이전에 부수 효과를 일으킨다.

      후위 연산자로 사용하면 표현식으로부터 값이 반환된 이후에 부수효과를 일으킨다.

      `(a++)` 을 한다고 부수 효과를 캡슐화할 수 있는 것은 아니다.

    - delete의 부수 효과

      객체의 프로퍼티를 없애거나 배열에서 슬롯을 제거할 때 사용한다.

      delete 연산자의 결과값은 유효하거나 허용된 연산일 경우 true, 그 외에는 false를 반환한다. 부수 효과는 프로퍼티나 배열의 슬롯을 제거하는 것이다.

    - = 할당 연산자의 부수 효과

        ```jsx
        let a;
        
        a = 42; // 42
        a; // 42
        ```

      `a = 42` 에서 =  연산자는 아무 일이 없는 것 같지만, 42를 a에 할당하는 것 자체가 본질적으로 부수 효과이다.


    ### 콘텍스트 규칙
    
    같은 구문이어도 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다.
    
    - 객체 리터럴
        
        ```jsx
        let a = {
        	foo : bar()
        };
        ```
        
    - 레이블
        
        ```jsx
        {
        	foo : bar()
        };
        
        // 레이블 문 예시
        
        var i, j;
        
        loop1:
        for (i = 0; i < 3; i++) {      //첫번째 for문은 "loop1" 레이블을 붙였다.
           loop2:
           for (j = 0; j < 3; j++) {   //두번째 for문은 "loop2" 레이블을 붙였다.
              if (i === 1 && j === 1) {
                 continue loop1;
              }
              console.log('i = ' + i + ', j = ' + j);
           }
        }
        
        // 출력 결과:
        //   "i = 0, j = 0"
        //   "i = 0, j = 1"
        //   "i = 0, j = 2"
        //   "i = 1, j = 0"
        //   "i = 2, j = 0"
        //   "i = 2, j = 1"
        //   "i = 2, j = 2"
        // 다음 두 경우를 어떻게 스킵하는지 주목 : "i = 1, j = 1", "i = 1, j = 2"
        ```
        
        어디에도 할당되지 않은 고립된 객체 리터럴처럼 보이지만, { }는 평범한 코드 블록이다. 이 코드 블록은 for/while 이나 if 조건 등에 붙어 있는 코드 블록과 기능적으로 매우 유사하다. 
        
    - 블록
    - 분해 할당
        
        ```jsx
        function getData(){
        	// ...
        	return{
        		a : 42,
        		b : "foo"
        	}
        }
        
        let { a, b } = getData();
        console.log( a, b ); // 42 "foo" 
        ```
        
    
    ### 연산자 우선 순위
    
    연산자 갯수가 많아짐에 따라 연사자 별로 우선 순위가 존재한다.
    
    ```jsx
    let a = 42,b;
    b = (a++, a);
    
    a; // 43
    b; // 43
    
    let a = 42,b;
    b = a++, a;
    
    a; // 43
    b; // 42
    ```
    
    다음과 같은 결과가 나오는 이유는 ,연산자가 = 연산자보다 우선순위가 낮기 때문이다. 때문에 연산자를 사용할 때 할당문을 ()으로 감싸는 작업은 중요하다.
    
    ```jsx
    (false && true) || true; // true
    false && (true || true); // false
    false && true || true; // true
    true || false && false // true
    ```
    
    위 구문을 보면 `&&` 연산자가 `||` 연산자보다 우선순위가 높은 것을 확인할 수 있다.
    
    - 삼항 연산자의 우선 순위
        
        ```jsx
        a && b || (c ? c || (b ? a : c) && b : a) // false!
        (a && b || c) ? (c || b) ? a : (c && b) : a // true!
        ```
        
        연산자 우선 순위가 && ? || > ? : 순서로 생기기 때문에 아랫줄이 맞는 형태이다. 
        
        - 결합성
            
            우선 순위가 동일한 다수의 연산자의 경우 처리 순서는 좌측 결합성이냐 우측 결합성이냐에 따라 나뉜다. 
            
    
    ### 단락 평가
    
    &&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정된 경우 우측 피연산자의 평가를 건너 뛴다. 
    
    ```jsx
    function hello(){
    	if(false && true){
    		// ...
    	}
    }
    ```
    
    위와 같은 경우에 좌측 피연산자가 이미 false이므로 전체 결과값을 확정해버린다.

- Web Browser vs NodeJS

  브라우저와 노드JS는 동일한 V8 엔진을 사용한다.

  ### 브라우저와 노드의 존재 목적

  브라우저는 HTML, CSS, JS를 실행해 웹 페이지를 화면에 띄우는 것을 목적으로하고, 노드는 서버 개발 환경을 제공하는 것이 목적이다. → 사용되는 환경이 다르다.

  위와 같은 이유 때문에 둘 다 ECMAScript를 실행할 수는 있지만, 각 환경에서 자신의 특수한 목적을 실현시키기 위해 제공되는 API들이 서로 호환되지 않는다.

  Web Browser API : history, window, setTimeout 등등,,

  NodeJS API : crypto(비밀 번호 암호화 모듈), fs 등등,,

  ### 사용 방식

  Web Browser는 ECMAScript 모듈 표준을 사용한다. 이로 인해 import를 사용해 다른 파일의 코드를 불러오는 반면, NodeJS는 CommonJS 모듈 시스템을 사용하기 때문에 require()를 사용해야한다.

    - CJS에서 require()는 동기로 이뤄진다. 이 때문에 promise나 콜백호출을 리턴하지 않는다.
    - ESM은 모듈로더를 비동기 환경에서 실행한다. import와 export 구문을 찾는다. 찾은 스크립트를 비동기로 다운로드하여 파싱한 다음, 더 이상 import 할 것이 없어질 때까지 import를 찾은 다음, dependecies의 모듈 그래프를 만들어낸다. 이 과정이 끝나면 실행될 준비를 마치게 되며, 그 스크립트에 의존하고 있는 스크립트들도 실행할 준비를 마치게 되고, 실행된다.
      → 다운로드는 병렬로 되지만, 실행은 순차적으로 된다.
    - ESM에선 CommonJS의 default export는 사용할 수 있지만, named export는 사용할 수 없다. 이는 named export를 실행단계에서 연산하지만, ESM은 named exports를 파싱 단계에서 연산하기 때문이다.