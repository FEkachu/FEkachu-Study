# [part2]2. 렉시컬 스코프

스코프의 작동 방식

- 동적 스코프    : 함수를 어디서 호출하는 지에 따라 상위 스코프 결정
- 렉시컬 스코프 : 함수를 어디서 선언하는 지에 따라 상위 스코프 결정

## 2.1 렉스 타임

- 컴파일러 단계 : 토크나이징/렉싱 단계부터 시작
- 렉싱 처리 과정 : 소스코드 문자열을 분석하여 상태유지 파싱의 결과로 생성된 토큰에 의미를 부여
- 렉시컬 스코프 = 렉싱 타임에 정의되는 스코프

  → 개발자가 코드를 짤 때 변수와 스코프 블록을 어디서 작성하는가에 따라 렉서가 코드를 처리할 때 확정

    - 예시 - 3개의 중첩 스코프

        ```jsx
        function hello(a){
            var b = a*2;
            function bye(c){
                console.log(a, b, c);
            }
            bye (b*3);
        }
        hello(2);
        ```

        - 스코프 버블 1 : 글로벌 스코프, 안에 `hello()`만 존재
        - 스코프 버블 2 : hello를 감싸는 스코프, 안에 `변수 a, b`, `bye()` 존재
        - 스코프 버블 3 : bye를 감싸는 스코프, 안에 `console.log()`만 존재

  ### 2.1.1 검색

  : 엔진은 스코프 버블의 구조와 상대적 위치를 통해 어디를 검색해야 확인자를 찾을 수 있는지 안다.

    - 위의 코드에서 `console.log()` 를 실행하고 3개의 참조된 변수 a,b,c 를 검색
    - 검색은 가장 안쪽 스코프 버블인 3번 `bye()함수의 스코프`에서 시작
    - `a`를 찾지 못하면 다음 가까운 스코프인 2번 `hello()의 스코프`로 한단계 올라감
    - `hello()의 스코프` 에서 `a`를 찾음
    - 이와 같은 방식이 `b`에도 적용
    - `c`는 `bye() 내부`에서 찾을 수 있음
   
 
  → 스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단

- 여러 중첩 스코프 층에 걸쳐 같은 확인자 이름을 정의 할 수 있음

  → 섀도잉 : 더 안쪽의 확인자가 더 바깥쪽의 확인자를 가리키는 것

- 섀도잉에 상관없이 스코프 검색은 항상 실행 시점에서 가장 안쪽 스코프 → 목표 일치하는 대상까지 진행
- 어떤 함수가 어디서 또는 어떻게 호출되는 지에 상관없이 함수의 렉시컬 스코프는 함수가 선언된 위치에 따라 정의

### 2.1.2 렉시컬 속이기

: 렉시컬 스코프는 작성시 개발자가 함수를 어디에 선언했는지에 따라 결정

→ 런 타임때 어떻게 렉시컬 스코프를 수정 할 수 있는가(속일 수 있는가)⁉️

- 방법 1 : `eval()` 이용
    - 하나 이상의 선언문을 포함하는 코드 문자열을 해석하여 렉시컬 스코프가 있다면 런타임에 수정
- 방법 2 : `with()` 이용
    - 속성을 가진 객체를 받아 마치 하나의 독립된 렉시컬 스코프처럼 취급
    - 객체참조를 하나의 스코프로, 속성을 확인자로 간주하여 런타임에 새로운 렉시컬 스코프를 탄생

  → 둘다 최적화작업을 무산, 사용 ❌