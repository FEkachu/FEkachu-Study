## 3.1 함수 기반 스코프

- 자바스크립트는 함수 기반 스코프!

```jsx
function foo(a){
    var b = 2;
    function bar(){
        
    }
    var c = 3;
}
console.log(b, c); //Reference Error
```

- `b`, `bar()`, `c`는 모두 `foo`의 스코프 버블에 속함
- `foo()`바깥에서는 이들에게 접근할 수 없다 →`ReferenceError 발생`

## 3.2 일반 스코프에 숨기

- 코드에서 임의의 부분의 함수 선언문으로 감싼다 → 해당코드를 **숨기는** 효과
- 해당 코드 주위에 새로운 스코프 버블이 생성 → 함수 스코프로 둘러싸여 변수와 함수를 ‘숨길' 수 있다
- 그렇다면 이러한 숨기는 방식은 어디에 유용한가⁉️

  ### → ‘최소 권한 원칙'과 관련

  : 모듈 객체의 API와 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 ‘숨겨야' 한다는 원칙

    - 이 원칙은 어떤 스코프가 변수와 함수를 포함하는 지에 관한 문제와도 관련
    - if, 모든 변수와 함수가 글로벌 스코프에 위치 → 어떤 하위 스코프에서도 이들 접근 가능

      → 최소 권한 원칙 위배


    <aside>
    💡 최소 권한 원칙이란⁉️
    주어진 사용자가 합법적인 이유로 **필요한 정보와 리소스에만 액세스** 할 수 있어야 한다는 계산의 설계 목표를 나타내는 정보 보안 용어
    
    </aside>


### 3.2.1 충돌 회피

- ‘숨기는 것’의 또다른 장점은 같은 이름을 가졌지만 다른 용도를 가진 두 확인자가 충돌하는 것을 피할 수 있다.
- 이러한 충돌은 예상치 못한 변수값 겹쳐쓰기를 초래

  → 스코프를 이용해서 내부에 선언문을 ‘숨기는’ 것이 좋은 선택지


### 글로벌 ‘네임스페이스’

- 글로벌 스코프에서 변수 충돌이 일어나기 쉬운 경우
    - 변수가 적절히 숨겨져 있지 않은 여러 라이브러리를 한 프로그램에서 불러오는 경우
    - 이런 라이브러리는 일반적으로 글로벌 스코프에 하나의 고유 이름을 가지는 객체 선언문을 생성
    - 이후 객체는 해당 라이브러리의 ‘네임스페이스'로 이용
    - 네임스페이스를 통해 최상위 스코프의 확인자가 아니라 속성 형태로 라이브러리의 모든 기능이 노출

### 모듈 관리

- 충돌방지를 위해 다양한 의존성 관리자를 이용한 ‘모듈' 접근법이 존재
- 어떤 라이브러리도 확인자를 글로벌 스코프에 추가할 필요 없이 특정 스코프로부터 의존성 관리자를 이용한 다양한 명시적인 방법으로 확인자를 가져와 사용할 수 있다.
- 렉시컬 스코프의 규칙에서 벗어날 수 있는 것❌
    - 스코프의 규칙을 적용해 모든 확인자가 공유 스코프에 누출되는 것을 방지

---

## 3.3 스코프 역할을 하는 함수

```jsx
var a = 2;
function foo(a){
    var a = 3;
    console.log(a);  //3
}

foo();
console.log(a); //2
```

- 위와 같은 방식은 **이상적인** 방법 ❌
    - `foo()`  라는 이름의 함수를 선언해야함
    - `foo()`를 실행시켜야 실행가능

→ 그렇다면 함수이름 없이 자동으로 실행시키는 방법은⁉️

- 함수 표현식 사용

    ```jsx
    var a = 2;
    (function foo(a){
        var a = 3;
        console.log(a);  //3
    })();
    
    console.log(a); //2
    ```

  → 여기서 `foo()`는 자신의 내부 스코프에 묶임

    - 바깥 스코프에서는 발견 ❌


    <aside>
    💡 함수 표현식이란⁉️
  
    - function이 구문 시작 : 함수 선언문
    - 나머지는 함수 표현식

    </aside>


## 3.4 **블록 스코프**

: 변수를 실제 사용하는 곳에서 가깝게 배치하여 최대한 작은 유효 범위를 갖도록 하기 위해 사용

- 블록 스코프를 구성하는 방법
    - with
    - try/catch
    - let/const

### **with**

`with` 문 안에서 생성된 객체는 바깥 스코프에 영향을 미치지 않고, 문 안에서만 존재하다가 문이 끝남과 동시에 사라진다.

### **try/catch**

```jsx
try {
  //...
} catch (e) {
  console.log(e);
}

console.log(e); // Reference Error
```

try/catch 구문 중 `catch` 문에서 선언된 변수는 `catch` 블록 스코프에 속한다.

### **let/const**

ES6에서 변수를 선언하는 방법으로 `let`, `const` 키워드가 도입되었으며 이 둘은 블록 스코프를 가진다.


<aside>
💡 block 이란⁉️

- 한 쌍의 중괄호`{}` 로 구성되며, 0개 이상의 구문을 묶을 때 사용
- 블록문을 쓰면 JavaScript가 하나의 문을 기대하는 곳에서 다수의 문을 실행할 수 있다.
    - JavaScript에서 이렇게 문을 묶는건 흔히 쓰이는 기법
- 다른 언어에서 블록문은 **복합문** 이라고 부르기도 한다.
- 주로 `if… else`, `for 구문`에서 많이 사용

1. **`var`
   :** `var로 선언된 변수`는 블록 범위를 갖지 **❌**

   블록 내에서 선언한 변수는 이 변수를 포함한 함수나 스크립트까지 범위가 지정되며, 변수의 설정 효과는 블록을 넘어서도 지속된다. 즉, **블록문에 범위가 도입되지 않는다.**

    ```jsx
    var x = 1;
    {
      var x = 2;
    }
    console.log(x); //2
    ```

   : 블록 안의 `var x`과 블록 앞의 `var x` 문과 동일한 범위에 있기 때문

   → 엄격한 모드에서는 블록 내부의 함수 선언이 이상하게 동작, 사용 ❌

2. **`let`**, **`const`**

   : `[let](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let)`과 `[const](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/const)`로 선언한 식별자는 블록 범위를 가짐.

    ```jsx
    let x = 1;
    {
      let x = 2;
    }
    console.log(x); //1
    ```

    : `x = 2`는 선언한 블록으로 범위가 제한

- const 도 마찬가지

    ```jsx
    const c = 1;
    {
       const c = 2;
    }
    console.log(c); // 1
    ```

</aside>

Reference

[block - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/block#description)

[](https://ko.theastrologypage.com/principle-least-privilege)
