# [part2] 1. 스코프란 무엇인가

- 프로그램 언어 : 변수에 값을 저장, 저장된 값을 사용하고 수정하는 기능 → 프로그램에서 상태를 나타냄
- 이렇게 변수를 프로그램에 추가하면 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는데 잘 정의된 규칙이 필요 → 스코프

## 1.1 컴파일러 이론

- 자바스크립트 : **컴파일러 언어(**일반적으로는 **‘동적'** 또는 **‘인터프리터’ 언어**로 분류**)**
- 컴파일레이션
    - 전통적인 컴파일러 언어의 처리과정에서 프로그램을 이루는 소스코드가 실행되기 전에 보통적으로 거치는 3단계

        <aside>
        💡 1. 토크나이징/렉싱

      : 문자열을 토큰으로 만드는 과정. 무상태 방식과 상태방식에 따라 토크나이징(무상태)인지 렉싱(상태)인지 구분

        - 렉싱같은 경우 상태 유지 파싱 규칙을 적용해 a가 별개의 토큰인지 다른 토큰의 일부인지를 파악
        - 토큰 : 의미있는 조각
        - 예시
            - `var a = 1;`

              [토큰]

                - `var`
                - `a`
                - `=`
                - `1`
                - `;`

      → 빈칸 : 의미를 가지느냐의 따라 다름

        1. 파싱

           : 토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리형태로 바꾸는 과정

            - 파싱의 결과로 만들어진 트리 : AST(추상구문 트리)
                - `var a = 1;`
                - 최상위 노드 : 변수선언
                - 자식노드 : 확인자-`a`, 대입수식- `=`
                - 대입 수식 노드의 자식노드 : 숫자리터럴-`2`
        2. 코드생성

           : AST를 컴퓨터에서 실행 코드로 바꾸는 과정 → 언어에 따라, 목표 플랫폼에따라 크게 달라짐

        </aside>

      : 자바스크립트 엔진은 파싱과 코드 생성과정에서 불필요한 요소를 삭제 → 실행 성능 최적화

        - 자바 스크립트엔진이 기존 컴파일러와 다른점
            - 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않음
            - 자바스크립트 컴파일레이션 : 코드 실행 수백만 분의 일초 전 수행
---
    💡 ⁉️컴파일러 언어 vs 인터프리터 언어⁉️

    - 컴파일러 언어

      : 고급언어로 작성된 소스코드를 저급언어(기계어/어셈블리어)로 번역하는 프로그램

        - 컴파일러를 이용해 컴파일 타임에 전체 소스코드를 저급언어로 변환, 실행파일 생성
        - 컴파일 단계와 실행단계 분리
        - 컴파일은 단 한번만 수행, 실행은 실행파일을 실행하므로써 진행
        - 실행시 컴파일 거치지 않음 → 실행속도 빠름
        - 큰 프로젝트의 경우 컴파일 시간이 오래걸림
        - 운영체제 이식성 낮음

          : OS마다 실행할 수 있는 기계어가 다른 경우 존재, 그때마다 해당 컴파일러로 다시 컴파일 과정 수행

    - 인터프리터 언어

      : 프로그래밍 언어의 소스코드를 바로 실행하는 프로그램

        - 컴파일 하지 않고 소스코드를 한 줄 씩 읽어 실행
        - 컴파일 ❌
        - 실행시 인터프리터 과정을 반복 → 실행속도 느림
        - 운영체제 이식성 좋음

 ---
    💡 ⁉️ 정적 언어 vs 동적 언어 ⁉️

    - 정적 언어

      : 컴파일 시 변수 타입이 결정되는 언어

        - 자료형이 컴파일시 결정되기 위해서는 소스코드에 명시적으로 자료형 지정
        - 장점 : 타입에러에 대한 문제를 컴파일 타임에 해결가능(안정성 ↑)
        - 단점 : 타입제한으로 코드 작성시 유연성 ↓
    - 동적 언어

      : 런타임(실행파일이 실행된 이후)시 자료형이 결정되는 언어

        - 자료형이 런타임에 결정 → 소스코드에서 명시적으로 지정해줄 필요 ❌
        - 장점 : 소스코드 작성시 타입 제약❌ → 유연성↑, 코드 작성이 효율적
        - 단점 : 타입에 대한 리스크를 런타임에 감당(스펠링 오류 포함)


---

## 1.2 스코프 이해하기

- `var a = 1;` 에서의 컴파일러의 수행
    1. 컴파일러 변수 선언

       : 컴파일러가 `var a` 를 만나면 스코프에게 `변수 a` 가 특정한 스코프 컬렉션 안에 있는지를 물음

       → `변수 a`가 이미 있다면 컴파일러는 선언 무시, 그렇지 않으면 컴파일러는 `새로운 변수 a`를 스코프 컬렉션 내에 선언하라고 요청

    2. 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입

       : 컴파일러는 `a = 2` 대입문을 처리하기 위해 나중에 엔진이 실행할 수 잇는 코드를 생성

       → 엔진이 실행하는 코드는 먼저 스코프에게 `a라고 부르는 변수`가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인

        - 가능하다면 엔진은 변수 a를 사용, 아닌경우 엔진은 다른곳을 살핌

    ---


### 1.2.1 컴파일러

: 컴파일러가 생성한 코드를 샐해할 때 엔진은 변서 a 가 선언된 적이 있는지 스코프에서 검색

→ 검색종류에 따라 결과가 달라짐

- 대입의 연산 방향에 따라 종류 구분
    - LHS(Letf-Hand Side)

      : 변수가 대입 연선자 왼쪽에 있을 때 수행 (대입할 대상)

        - 값을 넣어야 하기에 변수 컨테이너 자체를 찾음
        - 예시 `a = 2;`

          : `a` 값을 신경 쓸 필요 없이 `=2` 대입 연산을 수행할 대상 변수를 찾음

        - 참조 대상을 찾지 못하면 자동적/암시적으로 글로벌 스코프에 같은 이름의 새로운 변수가 생성
            - Strict Mode에서는 `ReferenceError`발생
    - RHS(Right-Hand Side)

      : 변수가 대입연산자 오른쪽에 있을 때 수행(정확히는 왼편이 아닌 쪽 → 대입할 값)

        - 값을 가져오는 것
        - 예시 `console.log(a);`

          : `a`에 아무것도 대입 ❌, `a`의 값을 가져와 `console.log`에 넘겨줌

        - 참조 대상을 찾지 못하면 `ReferenceError`발생
    - 예시

        ```jsx
        function hello(a){ //2. LHS : 인수로 넘겨받은 2를 a에 대입
            console.log(a); //3. RHS : a에 대한 RHS
                            //4. RHS : 3의 결과가 console.log에 넘겨짐, console 객체를 RHS하여 log 메서드를 확인 
                            // 5. LHS : log()의 인자에 2 대입
        }
        hello(2);   //1. RHS
        ```


---

## 1.3 중첩 스코프

: 하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩 될 수 있음 → 스코프도 다른 스코프에 중첩될 수 있음

- 대상 변수를 현재 스코프에서 발견하지 못하면 엔진은 다음 바깥의 스코프로 넘어가는 식으로 변수를 찾음

  → 글로벌 스코프에 도달할 때 까지 계속 반복


참고

- 컴파일러 언어 vs 인터프리터 언어 - [https://velog.io/@congaweb/compiler-interpreter](https://velog.io/@congaweb/compiler-interpreter)
- 컴파일러 언어 vs 인터프리터 언어 : 운영체제 이식성 - [https://jooona.tistory.com/156](https://jooona.tistory.com/156)
- 정적언어 vs 동적언어 - [https://algorfati.tistory.com/112](https://algorfati.tistory.com/112)