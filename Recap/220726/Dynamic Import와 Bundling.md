<aside>
💡 🌟중요🌟 Dynamic import

</aside>

웹 페이지의 속도를 결정 짓는 첫번째 요소는 **첫 페이지를 그릴 때 필요한 자원의 양**이다. 필요한 자원이 많을수록 네트워크 상에서 다운 받는 시간이 오래 걸린다.

번들러가 모든 JS 코드를 하나의 거대한 파일로 만들고 웹페이지에서는 이 큰 JS 파일을 모두 불러올 때까지 렌더링을 멈춘다.

웹사이트의 속도를 올리기 위해서는 큰 JS 파일의 용량을 줄여야 하는데, 크게 코드의 크기를 줄이는 방법과 코드를 분할하는 방법이 있다.

그 중 코드를 분할하는 방법 중 하나인 `dynamic import`에 대해서 알아보겠다.

### 코드 분할 (Code Splitting)

Webpack으로 빌드한 파일은 애플리케이션의 모든 페이지의 내용을 하나의 파일에 담고 있고, 이를 모두 렌더링 하더라도, 사용자가 보는 페이지는 얼마 되지 않는다.

이를 여러 페이지에서 필요한 파일로 나누고 필요한 시점마다 불러올 수 있도록 나눈다면, 첫 렌더링에 필요한 파일의 크기를 줄여 더 빠르게 렌더링 할 수 있다.

### Dynamic import

대부분의 코드들은 사용자가 보는 첫 페이지에는 필요하지 않다.

첫 페이지 진입시에 필요한 최소한의 코드만 다운 받고, 사용자가 특정 페이지나 위치에 도달할 때마다 코드를 로드한다면, 첫 페이지의 초기 성능을 올릴 수 있다. 이런 방식을 lazy-load(게으른 로딩)이라고 한다.

`Dynamic Import` 를 사용하면, 런타임 시에 필요한 `module` 을 `import` 할 수 있다.

Dynamic import는,

- `import(경로)` 형태로 사용한다.
- `Promise` 를 반환하며, `export` 하는 값들을 가진 객체를 반환한다.

`Dynamic Import` 는 일반적인 정적인 `Module Import` 를 **필요한 시점**에 로드할 수 있도록 한다.

이를 이용하면, 거대한 하나의 JS를 여러 JS로 쪼갤 수 있게 되고, 화면이 위치할 때마다, 사용자가 클릭할 때마다 Import 함으로써, 코드를 분할하여 관리할 수 있게 된다.

[Dynamic Import 로웹페이지 성능 올리기](https://pks2974.medium.com/dynamic-import-%EB%A1%9C%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%84%B1%EB%8A%A5-%EC%98%AC%EB%A6%AC%EA%B8%B0-caf62cc8c375)

<aside>
💡 번들링(Bundling)을 하는 이유

</aside>

번들링에 대하여 들어본적이 있는가? 번들이라는 단어는 자주 들어봤을 것이다. 마트 같은데서 과자나 아이스크림 같은 것을 번들이라고 묶어서 판매하는 것을 본 적이 있을 것이다. 이처럼 번들링은 여러 개를 하나로 묶는다는 의미를 갖고, 개발에 있어서는 여러 개의 흩어져 있는 파일들을 하나의 파일로 모아준다라는 의미를 갖는다.

그렇다면 왜 여러 개의 파일을 하나의 파일로 모아줘야 할까? 그게 어떤 의미가 있을까? 보통 이런 질문을 한다면 대부분은 용량을 줄여주기 때문이라고 대답한다. 물론 맞는 말이다. Webpack이나 Rollup, Parcel 등의 번들러를 사용하여 번들링을 진행하면 파일들을 압축하고 난독화한다. 예를 들어 hello world라는 콘솔을 출력하는 Hello라는 function이 있다고 가정했을 때, 번들링 후의 결과 파일의 함수 이름은 Hello가 아닐 것이다. a라든지, b라든지 어차피 컴퓨터만 구분할 수 있으면 되기 때문에 간단한 이름으로 줄여버린다. 또한 개발 과정에서는 쾌적한 개발 경험을 위해 공백, 띄어쓰기, 줄바꿈 등을 사용하는데 번들러는 이 간격마저도 줄여버린다. 따라서 파일의 용량은 작아지는 것이 당연하다. 하지만 이 용량의 변화는 번들링의 전체적인 효과에 비해서는 매우 미미한 영역이다.

컴퓨터 네트워크 시간에 TCP 통신에 대해 들어본 적이 있을 것이다. TCP란 응용 프로그램이 데이터를 교환할 수 있는 네트워크 대화를 설정하고 유지하는 방법을 정의하는 표준이다. 데이터와 연결을 맺는 과정은 3-Way-HandShake 과정으로 이뤄진다. 그리고 데이터와 연결을 끊는 과정은 4-Way-HandShake 과정으로 이루어진다. 우리가 만든 웹서비스가 서버로부터 데이터를 한 번 받아올 때마다 총 7번의 HandShake가 발생하는 것이다. 만약 웹서비스가 받아와야 할 파일의 개수가 수백, 수천, 수만개라면 HandShake의 횟수는 어마무시할 것이다. 여기서 번들링의 장점이 발휘된다. 번들링은 같은 유형의 파일들을 하나로 묶어줌으로써 이 HandShake의 횟수를 획기적으로 줄여줄 수 있다. 데이터 통신에 따른 오버헤드를 줄여줌으로써 해당 웹서비스를 사용하는 사용자의 경험에 도움을 줄 수 있다.

[TCP 통신에 대해서 알아보자...](https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90....html)

[[ 네트워크 쉽게 이해하기 13편 ] 물데네전세표응 ㅡ OSI 7계층 , 상위계층](https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-13%ED%8E%B8-%EB%AC%BC%EB%8D%B0%EB%84%A4%EC%A0%84%EC%84%B8%ED%91%9C%EC%9D%91-%E3%85%A1-%EC%9D%91%ED%91%9C%EC%84%B8%EC%A0%84%EB%84%A4%EB%8D%B0%EB%AC%BC-OSI-7%EA%B3%84%EC%B8%B5)

<aside>
💡 type이 module일 때 즉시 실행 함수를 사용하는 게 의미가 있을까?

</aside>

### 즉시 실행함수(IIFE)

**즉시 실행 함수 (IIFE, Immediately Invoked Function Expression)**는 정의되자마자 즉시 실행되는 Javascript Function을 말한다. 즉시실행 함수(IIFE)는 **변수를 전역(global scope)으로 선언하는 것을 피하기 위해** 사용을 한다.

### 모듈

모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 모듈은 세부 사항을 캡슐화하고 공개가 필요한 API만을 외부에 노출한다.

C 언어는 #include, Java는 import 등 대부분의 프로그래밍 언어는 모듈 기능을 가지고 있다. 하지만 클라이언트 사이드 자바스크립트는 script 태그를 사용하여 외부의 스크립트 파일을 가져올 수는 있지만, 파일마다 독립적인 파일 스코프를 갖지 않고 **하나의 전역 객체(Global Object)를 공유**한다. 즉, 자바스크립트 파일을 여러 개의 파일로 분리하여 script 태그로 로드하여도 분리된 자바스크립트 파일들이 결국 하나의 자바스크립트 파일 내에 있는 것처럼 하나의 전역 객체를 공유한다. 따라서 분리된 자바스크립트 파일들이 하나의 전역을 갖게 되어 전역 변수가 중복되는 등의 문제가 발생할 수 있다.

자바스크립트를 클라이언트 사이드에 국한하지 않고 범용적으로 사용하고자 하는 움직임이 생기면서 모듈 기능은 반드시 해결해야 하는 핵심 과제가 되었다. 이런 상황에서 제안된 것이 `CommonJS`와 `AMD(Asynchronous Module Definition)`이다. 이렇게 두개로 나뉘어서 모듈을 사용하였으나,  ES6에서는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가하였다.

ES6 모듈은 파일 자체의 스코프를 제공한다. 즉, ES6 모듈은 독자적인 **모듈 스코프**를 갖는다. 따라서, 모듈 내에서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

### 따라서..

### type = module 일때, 즉시 실행함수의 사용은⁉️

IIFE는 (모듈은 사용하고 싶지 않지만) 글로벌 스코프는 더럽히고 싶지 않을 때 사용하는 것이나,
모듈은 이미 독자적인 모듈 스코프를 갖기에 글로벌 스코프를 더럽히지 않는다. 결과적으로 module에서 IIFE를 사용하는 것은 **의미가 없다.**

참고

[IIFE - 용어 사전 | MDN](https://developer.mozilla.org/ko/docs/Glossary/IIFE)

[Module | PoiemaWeb](https://poiemaweb.com/es6-module)
